<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Ripserer.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Ripserer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Ripserer.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/basics/">Basics</a></li><li><a class="tocitem" href="../generated/stability/">Stability</a></li><li><a class="tocitem" href="../generated/cocycles/">Representative Cocycles</a></li><li><a class="tocitem" href="../generated/time_series_sublevel/">Sublevel Time Series Filtrations</a></li><li><a class="tocitem" href="../generated/image_sublevel/">Sublevel Image Filtrations</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Ripserer-1"><span>Ripserer</span></a></li><li><a class="tocitem" href="#Persistence-Intervals-and-Diagrams-1"><span>Persistence Intervals and Diagrams</span></a></li><li><a class="tocitem" href="#Filtration-Types-1"><span>Filtration Types</span></a></li><li><a class="tocitem" href="#Simplex-Types-1"><span>Simplex Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><h2 id="Ripserer-1"><a class="docs-heading-anchor" href="#Ripserer-1">Ripserer</a><a class="docs-heading-anchor-permalink" href="#Ripserer-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.ripserer" href="#Ripserer.ripserer"><code>Ripserer.ripserer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ripserer(dists::AbstractMatrix{T}; kwargs...)
ripserer(points; metric=Euclidean(), births, kwargs...)</code></pre><p>Compute the persistent homology of metric space represented by <code>dists</code> or <code>points</code> and <code>metric</code>. <code>points</code> must be an array of bitstypes, such as <code>NTuple</code>s or <code>SVectors</code>.</p><p><strong>Keyoword Arguments</strong></p><ul><li><code>dim_max</code>: compute persistent homology up to this dimension. Defaults to <code>1</code>.</li><li><code>modulus</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>. Defaults to <code>2</code>.</li><li><code>field_type</code>: use this type of field of coefficients. Defaults to <code>Mod{modulus}</code>.</li><li><code>threshold</code>: compute persistent homology up to diameter smaller than threshold. For non-sparse Rips filtrations, it defaults to radius of input space.</li><li><code>sparse</code>: if <code>true</code>, use <code>SparseRipsFiltration</code>. Defaults to <code>false</code>. If the <code>dists</code> argument is a sparse matrix, it overrides this option.</li><li><code>cutoff</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>. Defaults to <code>0</code>.</li><li><code>representatives</code>: if <code>true</code>, return representative cocycles along with persistence intervals. Defaults to <code>false</code>.</li><li><code>metric</code>: when calculating persistent homology from points, any metric from <a href="https://github.com/JuliaStats/Distances.jl"><code>Distances.jl</code></a> can be used. Defaults to <code>Euclidean()</code>.</li><li><code>births</code>: when calculating persistent homology from points, births can be used to add birth times to vertices. Defaults to all births equal to <code>0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/reduction.jl#L252-L277">source</a></section><section><div><pre><code class="language-none">ripserer(filtration::AbstractFiltration; dim_max=1)</code></pre><p>Compute persistent homology from <code>filtration</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/reduction.jl#L307-L311">source</a></section></article><h2 id="Persistence-Intervals-and-Diagrams-1"><a class="docs-heading-anchor" href="#Persistence-Intervals-and-Diagrams-1">Persistence Intervals and Diagrams</a><a class="docs-heading-anchor-permalink" href="#Persistence-Intervals-and-Diagrams-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.PersistenceInterval" href="#Ripserer.PersistenceInterval"><code>Ripserer.PersistenceInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PersistenceInterval{T, C}</code></pre><p>The type that represents a persistence interval. It behaves exactly like a <code>Tuple{T, Union{T, Infinity}}</code>, but may have a representative cocycle attached to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.birth-Tuple{PersistenceInterval}" href="#Ripserer.birth-Tuple{PersistenceInterval}"><code>Ripserer.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth(interval::PersistenceInterval)</code></pre><p>Get the birth time of <code>interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.death-Tuple{PersistenceInterval}" href="#Ripserer.death-Tuple{PersistenceInterval}"><code>Ripserer.death</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death(interval::PersistenceInterval)</code></pre><p>Get the death time of <code>interval</code>. When <code>T&lt;:AbstractFloat</code>, <code>Inf</code> is returned instead of <code>∞</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.persistence-Tuple{PersistenceInterval}" href="#Ripserer.persistence-Tuple{PersistenceInterval}"><code>Ripserer.persistence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death(interval::PersistenceInterval)</code></pre><p>Get the persistence of <code>interval</code>, which is equal to <code>death - birth</code>. When <code>T&lt;:AbstractFloat</code>, <code>Inf</code> is returned instead of <code>∞</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.representative-Tuple{PersistenceInterval}" href="#Ripserer.representative-Tuple{PersistenceInterval}"><code>Ripserer.representative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative(interval::PersistenceInterval)</code></pre><p>Get the representative cocycle attached to <code>interval</code>. If representatives were not computed, throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.PersistenceDiagram" href="#Ripserer.PersistenceDiagram"><code>Ripserer.PersistenceDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PersistenceDiagram{P&lt;:PersistenceInterval} &lt;: AbstractVector{P}</code></pre><p>Type for representing persistence diagrams. Behaves exactly like an array of <code>PersistenceInterval</code>s, but is aware of its dimension and supports pretty printing and plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/diagram.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.barcode-Tuple{Union{AbstractArray{#s12,1} where #s12&lt;:PersistenceDiagram, PersistenceDiagram}}" href="#Ripserer.barcode-Tuple{Union{AbstractArray{#s12,1} where #s12&lt;:PersistenceDiagram, PersistenceDiagram}}"><code>Ripserer.barcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barcode(diagram; infinity=nothing)</code></pre><p>Plot the barcode plot or <code>AbstractVector</code> of diagrams. The <code>infinity</code> keyword argument determines where the infinity line is placed. If set to <code>nothing</code> the function tries to guess a good infinity poistion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/plotting.jl#L116-L122">source</a></section></article><h2 id="Filtration-Types-1"><a class="docs-heading-anchor" href="#Filtration-Types-1">Filtration Types</a><a class="docs-heading-anchor-permalink" href="#Filtration-Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractFiltration" href="#Ripserer.AbstractFiltration"><code>Ripserer.AbstractFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFiltration{T, V&lt;:AbstractSimplex{0, T}}</code></pre><p>A filtration is used to find the edges in filtration and to determine diameters of simplices.</p><p><code>T</code> is the distance type, accessible by <code>dist_type</code> and S is the edge type, accesible by <code>vertex_type</code>.</p><p><strong>Interface</strong></p><ul><li><a href="#Ripserer.n_vertices-Tuple{AbstractFiltration}"><code>n_vertices(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.edges-Tuple{AbstractFiltration}"><code>edges(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.diam-Tuple{AbstractFiltration,Any}"><code>diam(::AbstractFiltration, vs)</code></a></li><li><a href="#Ripserer.diam-Tuple{AbstractFiltration,AbstractSimplex,Any,Any}"><code>diam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any)</code></a></li><li><a href="#Ripserer.birth-Tuple{AbstractFiltration,Any}"><code>birth(::AbstractFiltration, v)</code></a> - optional, defaults to returning <code>zero(T)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.n_vertices-Tuple{AbstractFiltration}" href="#Ripserer.n_vertices-Tuple{AbstractFiltration}"><code>Ripserer.n_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n_vertices(filtration::AbstractFiltration)</code></pre><p>Return the number of vertices in <code>filtration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.edges-Tuple{AbstractFiltration}" href="#Ripserer.edges-Tuple{AbstractFiltration}"><code>Ripserer.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edges(filtration::AbstractFiltration)</code></pre><p>Get edges in distance matrix in <code>filtration</code>, sorted by decresing length and increasing combinatorial index. Edges should be of type <code>edge_type(filtration)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.diam-Tuple{AbstractFiltration,Any}" href="#Ripserer.diam-Tuple{AbstractFiltration,Any}"><code>Ripserer.diam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diam(flt::AbstractFiltration, vertices)</code></pre><p>Get the diameter of list of vertices i.e. diameter of simplex with <code>vertices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.diam-Tuple{AbstractFiltration,AbstractSimplex,Any,Any}" href="#Ripserer.diam-Tuple{AbstractFiltration,AbstractSimplex,Any,Any}"><code>Ripserer.diam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diam(flt::AbstractFiltration, simplex, vertices, vertex)</code></pre><p>Get the diameter of coface of <code>simplex</code> that is formed by adding <code>vertex</code> to <code>vertices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.birth-Tuple{AbstractFiltration,Any}" href="#Ripserer.birth-Tuple{AbstractFiltration,Any}"><code>Ripserer.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth(::AbstractFiltration{T}, v)</code></pre><p>Get the birth time of vertex <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractfiltration.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractFlagFiltration" href="#Ripserer.AbstractFlagFiltration"><code>Ripserer.AbstractFlagFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFlagFiltration{T, V} &lt;: AbstractFiltration{T, V}</code></pre><p>An abstract flag filtration is a filtration of flag complexes. Its subtypes can overload <code>dist(::AbstractFlagFiltration{T}, u, v)::Union{T, Infinity}</code> instead of <code>diam</code>. <code>diam(::AbstractFlagFiltration, ...)</code> defaults to maximum <code>dist</code> among vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/ripsfiltration.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.RipsFiltration" href="#Ripserer.RipsFiltration"><code>Ripserer.RipsFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RipsFiltration{T, V&lt;:AbstractSimplex{&lt;:Any, T}} &lt;: AbstractFlagFiltration{T, V}</code></pre><p>This type represents a filtration of Vietoris-Rips complexes. Diagonal items are treated as vertex birth times.</p><p><strong>Constructor</strong></p><pre><code class="language-none">RipsFiltration(
    distance_matrix;
    threshold=default_rips_threshold(dist),
    vertex_type=Simplex{0, T, Int64},
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/ripsfiltration.jl#L107-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.SparseRipsFiltration" href="#Ripserer.SparseRipsFiltration"><code>Ripserer.SparseRipsFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseRipsFiltration{T, V&lt;:AbstractSimplex{&lt;:Any, T}} &lt;: AbstractFlagFiltration{T, V}</code></pre><p>This type represents a filtration of Vietoris-Rips complexes. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as ∞. Diagonal items are treated as vertex birth times.</p><p><strong>Constructor</strong></p><pre><code class="language-none">SparseRipsFiltration(
    distance_matrix;
    threshold=nothing,
    vertex_type=Simplex{0, T, Int64},
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/ripsfiltration.jl#L158-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.CubicalFiltration" href="#Ripserer.CubicalFiltration"><code>Ripserer.CubicalFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubicalFiltration{T, N, V&lt;:Cubelet{0, T}} &lt;: AbstractFiltration{T, V}</code></pre><p>A <code>CubicalFiltration</code> is used to compute sublevel persistent homology on <code>N</code>-dimensional images, which are of type <code>AbstractArray{T, N}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/cubical.jl#L54-L59">source</a></section></article><h2 id="Simplex-Types-1"><a class="docs-heading-anchor" href="#Simplex-Types-1">Simplex Types</a><a class="docs-heading-anchor-permalink" href="#Simplex-Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractSimplex" href="#Ripserer.AbstractSimplex"><code>Ripserer.AbstractSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSimplex{D, T}</code></pre><p>An abstract type for representing simplices. A simplex must have a diameter of type <code>T</code>, which is its birth time. The dimension must be encoded in the type as <code>D</code> and can be accessed by <a href="#Ripserer.dim-Tuple{AbstractSimplex}"><code>dim</code></a>.</p><p><strong>Interface</strong></p><ul><li><code>AbstractSimplex{D}(::NTuple{D+1, &lt;:Integer}, ::T)</code></li><li><a href="#Ripserer.diam-Tuple{AbstractSimplex}"><code>diam(::AbstractSimplex)</code></a></li><li><a href="#Base.sign-Tuple{AbstractSimplex}"><code>Base.sign(::AbstractSimplex)</code></a></li><li><a href="#Base.:--Tuple{AbstractSimplex}"><code>Base.:-(::AbstractSimplex)</code></a></li><li><code>Base.isless(::AbstractSimplex, ::AbstractSimplex)</code></li><li><a href="#Ripserer.coface_type-Tuple{AbstractSimplex}"><code>coface_type(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.vertices-Tuple{AbstractSimplex}"><code>vertices(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.coboundary-Tuple{Any,AbstractSimplex}"><code>coboundary(::Any, ::AbstractSimplex)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.dim-Tuple{AbstractSimplex}" href="#Ripserer.dim-Tuple{AbstractSimplex}"><code>Ripserer.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(::AbstractSimplex)
dim(::Type{&lt;:AbstractSimplex})</code></pre><p>Get the dimension of simplex i.e. the value of <code>D</code>.</p><pre><code class="language-julia">dim(Simplex{2}((3, 2, 1), 3.2))

# output

2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.diam-Tuple{AbstractSimplex}" href="#Ripserer.diam-Tuple{AbstractSimplex}"><code>Ripserer.diam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diam(simplex::AbstractSimplex)</code></pre><p>Get the diameter of <code>simplex</code>.</p><pre><code class="language-julia">diam(Simplex{2}((3, 2, 1), 3.2))

# output

3.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L21-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{AbstractSimplex}" href="#Base.sign-Tuple{AbstractSimplex}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sign(simplex::AbstractSimplex)</code></pre><p>Get the orientation of <code>simplex</code>. Returns -1 or 1.</p><pre><code class="language-julia">sign(Simplex{2}((3, 2, 1), 3.2))

# output

+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{AbstractSimplex}" href="#Base.:--Tuple{AbstractSimplex}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(simplex::AbstractSimplex)</code></pre><p>Reverse the simplex orientation.</p><pre><code class="language-julia">-Simplex{2}((3, 2, 1), 3.2)

# output

2-dim Simplex(1, 1):
  -(3, 2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.coface_type-Tuple{AbstractSimplex}" href="#Ripserer.coface_type-Tuple{AbstractSimplex}"><code>Ripserer.coface_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coface_type(::AbstractSimplex)
coface_type(::Type{&lt;:AbstractSimplex})</code></pre><p>Get the type of coface a simplex hax. For a <code>D</code>-dimensional simplex, this is usually its <code>D+1</code>-dimensional counterpart. Only the method for the type needs to be implemented.</p><pre><code class="language-julia">coface_type(Simplex{2}((3, 2, 1), 3.2))

# output

Simplex{3, Float64, Int}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L74-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.vertices-Tuple{AbstractSimplex}" href="#Ripserer.vertices-Tuple{AbstractSimplex}"><code>Ripserer.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(simplex::AbstractSimplex{dim})</code></pre><p>Get the vertices of <code>simplex</code>. Returns <code>NTuple{dim+1, Int}</code>. In the algorithm, only the method for 2-simplices is actually used.</p><pre><code class="language-julia">vertices(Simplex{2}((3, 2, 1), 3.2))

# output

(3, 2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.coboundary-Tuple{Any,AbstractSimplex}" href="#Ripserer.coboundary-Tuple{Any,AbstractSimplex}"><code>Ripserer.coboundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coboundary(filtration, simplex[, Val{all_cofaces}])</code></pre><p>Iterate over the coboundary of <code>simplex</code>. Use the <code>filtration</code> to determine the diameters and validity of cofaces. Iterates values of the type <code>coface_type(simplex)</code>. If <code>all_cofaces</code> is <code>false</code>, only return cofaces with vertices added to the beginning of vertex list.</p><pre><code class="language-julia">filtration = RipsFiltration([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])

for c in coboundary(filtration, Simplex{1}(2, 1))
    println(c)
end

# output

Simplex{2}(+(4, 3, 1), 1)
Simplex{2}(-(3, 2, 1), 1)</code></pre><pre><code class="language-julia">for c in coboundary(filtration, Simplex{1}(2, 1), Val(false))
    println(c)
end

# output

Simplex{2}(+(4, 3, 1), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/abstractsimplex.jl#L128-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.IndexedSimplex" href="#Ripserer.IndexedSimplex"><code>Ripserer.IndexedSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndexedSimplex{D, T, I&lt;:Integer} &lt;: AbstractSimplex{D, T}</code></pre><p>A refinement of <a href="#Ripserer.AbstractSimplex"><code>AbstractSimplex</code></a>. An indexed simplex is represented by its dimension, diameter and combinatorial index. It does not need to hold information about its the vertices it includes, since they can be recomputed from the index and dimension.</p><p>By defining the <a href="#Ripserer.index-Tuple{AbstractSimplex}"><code>index</code></a>, a default implementation of <code>sign</code>, <code>isless</code>, <a href="#Ripserer.vertices-Tuple{AbstractSimplex}"><code>vertices</code></a> and <a href="#Ripserer.coboundary-Tuple{Any,AbstractSimplex}"><code>coboundary</code></a> is provided.</p><p><strong>Interface</strong></p><ul><li><code>IndexedSimplex{D[, T, I]}(index::I, diam::T)</code> - constructor.</li><li><code>IndexedSimplex{D[, T, I]}(vertices::NTuple{D+1, I}, diam::T)</code> - constructor.</li><li><a href="#Ripserer.diam-Tuple{AbstractSimplex}"><code>diam(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.coface_type-Tuple{AbstractSimplex}"><code>coface_type(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.index-Tuple{AbstractSimplex}"><code>index(::IndexedSimplex)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/simplex.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.index-Tuple{AbstractSimplex}" href="#Ripserer.index-Tuple{AbstractSimplex}"><code>Ripserer.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(vertices)</code></pre><p>Calculate the index from tuple of vertices. The index is equal to</p><div>\[(i_d, i_{d-1}, ..., 1) \mapsto \sum_{k=1}^{d+1} \binom{i_k - 1}{k},\]</div><p>where <span>$i_k$</span> are the simplex vertex indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/simplex.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Simplex" href="#Ripserer.Simplex"><code>Ripserer.Simplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Simplex{D, T, I} &lt;: IndexedSimplex{D, T, I}</code></pre><p>The vanilla simplex type represented by dimension <code>D</code> and index of type <code>I</code> and a diameter of type <code>T</code>.</p><p><strong>Constructor</strong></p><pre><code class="language-none">Simplex{D[, T, I]}(::I, ::T)</code></pre><p><strong>Examples</strong></p><p>```jldoctest julia&gt; Simplex{2}(2, 1) 2-dim Simplex{2}(2, 1):   +(4, 2, 1)</p><p>julia&gt; Simplex{10}(Int128(-10), 1.0) 4-dim Simplex{3}(1.0, 10, 2) with UInt128 index:   -(12, 11, 10, 9, 8, 7, 6, 5, 4, 2, 1) <code>˙</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/simplex.jl#L228-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cubelet" href="#Ripserer.Cubelet"><code>Ripserer.Cubelet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cubelet{D, T, I} &lt;: IndexedSimplex{D, T, I}</code></pre><p>A <code>Cubelet</code> is similar to a <code>Simplex</code>, but it has <code>2^D</code> vertices instead of <code>D+1</code>. Like in <code>Simplex</code>, the vertices are encoded from an index and dimension. Because a cubelet knows nothing about the image it came from, it returns <em>linear</em> indices from <code>vertices</code>.</p><p>The vertices should be neighboring indices, but this fact is not checked anywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b66f1a8a7dc1e9c0c3aa7a2ec6f048f333fba7a4/src/cubical.jl#L1-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/image_sublevel/">« Sublevel Image Filtrations</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 13 May 2020 08:31">Wednesday 13 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
