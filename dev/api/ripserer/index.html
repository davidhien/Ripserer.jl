<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Ripserer.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ripserer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Ripserer.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/basics/">Basics</a></li><li><a class="tocitem" href="../../generated/stability/">Stability</a></li><li><a class="tocitem" href="../../generated/cocycles/">Cohomology, Homology, and Representatives</a></li><li><a class="tocitem" href="../../generated/cubical/">Cubical Persistent Homology</a></li><li><a class="tocitem" href="../../generated/malaria/">Image Classification With Cubical Filtrations and Persistence Images</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Ripserer"><span>Ripserer</span></a></li><li><a class="tocitem" href="#Filtrations"><span>Filtrations</span></a></li><li><a class="tocitem" href="#Simplices"><span>Simplices</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Persistence-Diagrams"><span>Persistence Diagrams</span></a></li><li><a class="tocitem" href="#Experimental-Features"><span>Experimental Features</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../../related-work/">Related Julia Packages</a></li><li><a class="tocitem" href="../../references/">Acknowledgements and References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/api/ripserer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Ripserer"><a class="docs-heading-anchor" href="#Ripserer">Ripserer</a><a id="Ripserer-1"></a><a class="docs-heading-anchor-permalink" href="#Ripserer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.ripserer" href="#Ripserer.ripserer"><code>Ripserer.ripserer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ripserer(dists::AbstractMatrix; kwargs...)
ripserer(points; metric=Distances.Euclidean(1e-12), births, kwargs...)
ripserer(filtration::AbstractFiltration; kwargs...)</code></pre><p>Compute the persistent homology of metric space represented by <code>dists</code>, <code>points</code> and <code>metric</code>, or a <a href="../extensions/#Ripserer.AbstractFiltration"><code>Ripserer.AbstractFiltration</code></a>.</p><p>If <code>dists</code> or <code>points</code> are given, the <code>Rips</code> filtration is used.</p><p>If using points, <code>points</code> must be an array of <code>isbits</code> types, such as <code>NTuple</code>s or <code>SVector</code>s.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>dim_max</code>: compute persistent homology up to this dimension. Defaults to <code>1</code>.</p></li><li><p><code>modulus</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>. Defaults to <code>2</code>.</p></li><li><p><code>field_type</code>: use this type of field of coefficients. Defaults to <a href="#Ripserer.Mod"><code>Ripserer.Mod</code></a><code>{modulus}</code>.</p></li><li><p><code>threshold</code>: compute persistent homology up to diameter smaller than threshold. This parameter is only applicable when using distance matrices or points as input. When using filtrations, threshold must be passed to the filtration constructor. Defaults to the radius of the input space. When using low thresholds with points or distance matrices, consider using <code>sparse=true</code>.</p></li><li><p><code>cutoff</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>. Defaults to <code>0</code>.</p></li><li><p><code>reps</code>: if <code>true</code>, attach representative (co)cycles to persistence intervals. Can also be set to collection of integers to only find representatives in specified dimensions, e.g. <code>reps=1:2</code> will only find representatives in dimensions 1 and 2. This is useful for large filtrations (such as cubical) where calculating zero-dimensional representatives can be very slow.  Defaults to <code>false</code> for cohomology and <code>1:dim_max</code> for homology.</p></li><li><p><code>progress</code>: If <code>true</code>, show a progress bar. Defaults to <code>false</code>.</p></li><li><p><code>metric</code>: when calculating persistent homology from points, any metric from <a href="https://github.com/JuliaStats/Distances.jl"><code>Distances.jl</code></a> can be used. Defaults to <code>Distances.Euclidean(1e-12)</code>.</p></li><li><p><code>alg</code>: select the algorithm used in computation. The options are:</p><ul><li><p><code>:cohomology</code>: Default and fastest algorithm. When <code>reps</code> is set, intervals are equipped with representative <em>co</em>cycles.</p></li><li><p><code>:homology</code>: Significantly slower than <code>:cohomology</code>, but finds representative cycles. Does not find infinite intervals beyond dimension 0.</p></li><li><p><code>:involuted</code>: Use cohomology result to compute representative cycles. Can be extremely efficient compared to <code>:homology</code>, especially with <code>Rips</code> filtrations. Unlike <code>:homology</code>, this algorithm finds infinite intervals.</p></li></ul></li><li><p><code>implicit</code>: If <code>true</code>, an implicit reduction algorithm is used. Defaults to <code>true</code> for :cohomology and <code>:involuted</code>, and <code>false</code> for <code>:homology</code>. <code>implicit=false</code> is not recommended for <code>:cohomology</code> because it disables the emergent pairs optimization.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/computation/ripserer.jl#L1-L60">source</a></section></article><h2 id="Filtrations"><a class="docs-heading-anchor" href="#Filtrations">Filtrations</a><a id="Filtrations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtrations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Rips" href="#Ripserer.Rips"><code>Ripserer.Rips</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rips{I, T} &lt;: AbstractRipsFiltration{I, T}</code></pre><p>This type represents a filtration of Vietoris-Rips complexes.</p><p>Diagonal items in the input matrix are treated as vertex birth times.</p><p>Zero values are not allowed due to how sparse matrices work in Julia. If you need zero birth times, try offseting all values by a constant.</p><p>Threshold defaults to the radius of the input space. When using low <code>threshold</code>s, consider using the <code>sparse=true</code> keyword argument. It will give the same result, but may be much faster.</p><p><strong>Constructors</strong></p><ul><li><code>Rips(distance_matrix; threshold=nothing)</code></li><li><code>Rips(points; metric=Euclidean(1e-12), threshold=nothing)</code></li><li><code>Rips{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)][1:end-1];

julia&gt; ripserer(Rips(data))
2-element Array{PersistenceDiagrams.PersistenceDiagram,1}:
 100-element 0-dimensional PersistenceDiagram
 1-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(Rips(data, threshold=1.7))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0628, ∞)

julia&gt; using Distances

julia&gt; ripserer(Rips(data, metric=Cityblock()))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0888, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/filtrations/rips.jl#L176-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cubical" href="#Ripserer.Cubical"><code>Ripserer.Cubical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cubical{T, K} &lt;: AbstractFiltration{CartesianIndex{K}, T}</code></pre><p><code>Cubical</code> is used to compute sublevel persistent homology on <code>N</code>-dimensional images, which are of type <code>AbstractArray{T, N}</code>.</p><p>This type uses the CubeMap structure to find birth times of cubes (see reference).</p><p><strong>Constructor</strong></p><ul><li><code>Cubical(image::AbstractArray{T, N}, threshold=maximum(image))</code></li></ul><p><strong>Reference</strong></p><p>Wagner, H., Chen, C., &amp; Vuçini, E. (2012). <a href="https://link.springer.com/chapter/10.1007/978-3-642-23175-9_7">Efficient computation of persistent homology for cubical data.</a> In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; image = [1 0 0; 0 2 0; 0 0 0];

julia&gt; ripserer(Cubical(image))[1]
1-element 0-dimensional PersistenceDiagram:
 [0.0, ∞)

julia&gt; ripserer(Cubical(image))[2]
1-element 1-dimensional PersistenceDiagram:
 [1.0, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/filtrations/cubical.jl#L116-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Custom" href="#Ripserer.Custom"><code>Ripserer.Custom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Custom{I, T} &lt;: AbstractCustomFiltration{I, T}</code></pre><p>Build a custom filtration by specifying simplices and their birth times.</p><p>The list of simplices is corrected to form a valid filtration; birth times are corrected so a simplex is never born before its faces and missing simplices are added.</p><p>See the examples below for construction. Note how the unlisted 0-simplices were added with birth times equal to the lowest between their cofaces. The order in which simplices are given does not matter.</p><p>To create your own types of custom filtrations, subtype <a href="../extensions/#Ripserer.AbstractCustomFiltration"><code>AbstractCustomFiltration</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; flt = Custom([(1,) =&gt; 0, (4,) =&gt; 0, (1, 2) =&gt; 1, (1, 3) =&gt; 2, (1, 4) =&gt; 3, (2, 3) =&gt; 4, (2, 4) =&gt; 5, (3, 4) =&gt; 6, (1, 2, 3) =&gt; 7, (1, 2, 4) =&gt; 8, (1, 3, 4) =&gt; 9]; threshold=8)
Custom{Int64, Int64}(nv=4)

julia&gt; flt[0] # Can be indexed with dimension to list simplices
4-element Array{Simplex{0,Int64,Int64},1}:
 +Simplex{0}([4], 0)
 +Simplex{0}([2], 1)
 +Simplex{0}([3], 2)
 +Simplex{0}([1], 0)

julia&gt; ripserer(flt)[1]
2-element 0-dimensional PersistenceDiagram:
 [0.0, 3.0)
 [0.0, ∞)

julia&gt; ripserer(flt)[2]
3-element 1-dimensional PersistenceDiagram:
 [5.0, 8.0)
 [4.0, 7.0)
 [6.0, ∞)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/filtrations/custom.jl#L57-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Alpha" href="#Ripserer.Alpha"><code>Ripserer.Alpha</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Alpha{I, P&lt;:SVector} &lt;: AbstractFiltration{I, Float64}</code></pre><p><code>Alpha</code> filtrations are filtrations of the Delaunay complex.</p><p>They have much fewer simplices than <code>Rips</code>, so they are efficient even with large datasets, as long as their dimensionality is low.  What &quot;low&quot; means depends on the data, but this is definitely a good choice for 3D or lower. For high dimensional data, filtration construction may take a long time.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike most implementations, this one uses circumdiameters instead of circumradii. This makes the scale of the results comparable to <code>Rips</code>. If you need radius based values, divide your data or the resulting interval endpoints by 2.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This filtration uses <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>. Please see the installation instructions if constructions cause errors. MiniQhull currently has problems running on Windows. See <a href="https://github.com/gridap/MiniQhull.jl/issues/5">this issue</a> for more info.</p></div></div><p><strong>Constructors</strong></p><ul><li><code>Alpha(points; threshold, progress)</code>: <code>points</code> should be a vector of <code>Tuple</code>s, <code>SVector</code>s or similar.</li><li><code>Alpha{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices. Try using <code>I=Int128</code> if construction complains about overflow.</li></ul><p><strong>Reference</strong></p><p>Edelsbrunner, H. (1993, July). The union of balls and its dual shape. <a href="https://dl.acm.org/doi/abs/10.1145/160985.161139">In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231)</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = [(sin(t), cos(t), (t - π)^2) for t in range(0, 2π, length=101)[1:end-1]];

julia&gt; alpha = Alpha(data)
Alpha{Int64, Float64}(nv=100)

julia&gt; rips = Rips(data)
Rips{Int64, Float64}(nv=100, sparse=false)

julia&gt; length(Ripserer.edges(alpha))
197

julia&gt; length(Ripserer.edges(rips))
3613

julia&gt; sort(ripserer(alpha)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: 2-element Ripserer.Simplex{1,Float64,Int64}
 death_simplex: 3-element Ripserer.Simplex{2,Float64,Int64}

julia&gt; sort(ripserer(rips)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: 2-element Ripserer.Simplex{1,Float64,Int64}
 death_simplex: 3-element Ripserer.Simplex{2,Float64,Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/filtrations/alpha.jl#L130-L191">source</a></section></article><h2 id="Simplices"><a class="docs-heading-anchor" href="#Simplices">Simplices</a><a id="Simplices-1"></a><a class="docs-heading-anchor-permalink" href="#Simplices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Simplex" href="#Ripserer.Simplex"><code>Ripserer.Simplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Simplex{D, T, I&lt;:Integer} &lt;: AbstractSimplex{D, T, I}</code></pre><p>The vanilla simplex type represented by dimension <code>D</code>, an index of type <code>I</code>, and a birth time of type <code>T</code>.</p><p><strong>Constructors</strong></p><ul><li><code>Simplex{D[, T, I]}(index, birth)</code></li><li><code>Simplex{D}(vertices, birth)</code>: vertices must be sorted descending. This constructor mainly exists for debugging purposes. Using <a href="../extensions/#Ripserer.simplex"><code>simplex</code></a> is usually the better option.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Simplex{2}(2, 1)
2-dimensional Simplex(index=2, birth=1):
  +[4, 2, 1]

julia&gt; Simplex{10}(Int128(-10), 1.0)
10-dimensional Simplex(index=10, birth=1.0):
  -Int128[12, 11, 10, 9, 8, 7, 6, 5, 4, 2, 1]

julia&gt; Simplex{2}((5, 2, 1), 1)
2-dimensional Simplex(index=5, birth=1):
  +[5, 2, 1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/simplex.jl#L510-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cube" href="#Ripserer.Cube"><code>Ripserer.Cube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cube{D, T, K} &lt;: AbstractSimplex{D, T, CartesianIndex{K}}</code></pre><p>A <code>Cube</code> is similar to a <code>Simplex</code>, but it has <code>2^D</code> vertices instead of <code>D+1</code>. The vertices are encoded as the position in the CubeMap (see reference in <a href="#Ripserer.Cubical"><code>Cubical</code></a>). A <code>Cube</code>&#39;s vertices are of type <code>CartesianIndex{K}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Cube{1}(CartesianIndex(1, 2), 1.0)
1-dimensional Cube(index=CartesianIndex(1, 2), birth=1.0):
  +CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(1, 2)]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/filtrations/cubical.jl#L72-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.vertices-Tuple{Ripserer.AbstractSimplex}" href="#LightGraphs.vertices-Tuple{Ripserer.AbstractSimplex}"><code>LightGraphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(simplex::AbstractSimplex{dim, T, I})</code></pre><p>Get the vertices of <code>simplex</code>. Returns <code>SVector{length(simplex), I}</code>. When <code>index(simplex)</code> is an interger, a default implementation is provided.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; vertices(Simplex{2}((3, 2, 1), 3.2))
3-element StaticArrays.SArray{Tuple{3},Int64,1,3} with indices SOneTo(3):
 3
 2
 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/simplex.jl#L210-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth-Tuple{Ripserer.AbstractSimplex}" href="#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractSimplex}"><code>PersistenceDiagrams.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth(simplex::AbstractSimplex)</code></pre><p>Get the birth time of <code>simplex</code>, i.e. the time it first appears in the filtration.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; birth(Simplex{2}((3, 2, 1), 3.2))
3.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/simplex.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.dim-Tuple{Ripserer.AbstractSimplex}" href="#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractSimplex}"><code>PersistenceDiagrams.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(::AbstractSimplex)
dim(::Type{&lt;:AbstractSimplex})</code></pre><p>Get the dimension of a simplex i.e. the value of <code>D</code>. Can also be called on the type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dim(Simplex{2}((3, 2, 1), 3.2))
2

julia&gt; dim(Cube{3, Int, 4})
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/simplex.jl#L272-L288">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Mod" href="#Ripserer.Mod"><code>Ripserer.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Mod{M} &lt;: Integer</code></pre><p><code>Mod{M}</code> is the default field used by Ripserer. It is a representation of a finite field <span>$\mathbb{Z}_M$</span>, integers modulo small, prime <code>M</code>. Supports field arithmetic and can be converted to integer with <code>Int</code>.</p><p>Its values are not comparable on purpose.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Mod{3}(5)
2 mod 3

julia&gt; Mod{3}(5) + 1
0 mod 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/primefield.jl#L36-L55">source</a></section></article><h2 id="Persistence-Diagrams"><a class="docs-heading-anchor" href="#Persistence-Diagrams">Persistence Diagrams</a><a id="Persistence-Diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Persistence-Diagrams" title="Permalink"></a></h2><p>See also: <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/api/">PersistenceDiagrams.jl API</a>. For convenience, Ripserer reexports the following:</p><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.birth-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth(interval)</code></pre><p>Get the birth time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.death-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.death-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.death</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death(interval)</code></pre><p>Get the death time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.persistence-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.persistence-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.persistence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">persistence(interval)</code></pre><p>Get the persistence of <code>interval</code>, which is equal to <code>death - birth</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.representative-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.representative-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.representative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative(interval::PersistenceInterval)</code></pre><p>Get the representative (co)cycle attached to <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.birth_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical birth simplex of <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.death_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical death simplex of <code>interval</code>, if it has one.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An infinite interval&#39;s death simplex is <code>nothing</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.barcode" href="#PersistenceDiagrams.barcode"><code>PersistenceDiagrams.barcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barcode(diagram)</code></pre><p>Plot the barcode plot of persistence diagram or multiple diagrams in a collection. The <code>infinity</code> keyword argument determines where the infinity line is placed. If unset, the function tries to use <code>threshold(diagram)</code>, or guess a good position to place the line at.</p></div></section></article><h2 id="Experimental-Features"><a class="docs-heading-anchor" href="#Experimental-Features">Experimental Features</a><a id="Experimental-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-Features" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.reconstruct_cycle" href="#Ripserer.reconstruct_cycle"><code>Ripserer.reconstruct_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reconstruct_cycle(filtration, interval[, t]; distances=distance_matrix(filtration))</code></pre><p>Reconstruct the shortest representative cycle for the first homology group of given <code>interval</code>. The optional argument <code>t</code> sets the time at which the cycle is to be computed. It defaults to interval birth time, which gives a cycle similar to a representative cycle computed from homology. In general, higher times will yield nicer cycles. <code>t</code> can be a simplex or a number.</p><p>The optional <code>distances</code> keyword argument can be used to change the distance matrix used for determining edge lengths.</p><p>This method uses the representative cocycle to compute the cycle. As such, the interval must include a representative. To get such an interval, run <code>ripserer</code> with the keyword argument <code>reps=true</code> or <code>reps=1</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is still experimental.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/b03f27482130a5cc0bd7468a79724ccc607b9105/src/cycles.jl#L112-L130">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../benchmarks/">« Benchmarks</a><a class="docs-footer-nextpage" href="../extensions/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 17 October 2020 07:33">Saturday 17 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
