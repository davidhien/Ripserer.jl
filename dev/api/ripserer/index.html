<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Ripserer.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ripserer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Ripserer.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Ripserer"><span>Ripserer</span></a></li><li><a class="tocitem" href="#Filtrations"><span>Filtrations</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Persistence-Diagrams"><span>Persistence Diagrams</span></a></li><li><a class="tocitem" href="#Experimental-Features"><span>Experimental Features</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Interfaces</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/basics/">Basics</a></li><li><a class="tocitem" href="../../generated/stability/">Stability</a></li><li><a class="tocitem" href="../../generated/cocycles/">Cohomology, Homology, and Representatives</a></li><li><a class="tocitem" href="../../generated/cubical/">Cubical Persistent Homology</a></li><li><a class="tocitem" href="../../generated/malaria/">Image Classification With Cubical Filtrations and Persistence Images</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../related-work/">Related Julia Packages</a></li><li><a class="tocitem" href="../../references/">Acknowledgements and References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/api/ripserer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Ripserer"><a class="docs-heading-anchor" href="#Ripserer">Ripserer</a><a id="Ripserer-1"></a><a class="docs-heading-anchor-permalink" href="#Ripserer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.ripserer" href="#Ripserer.ripserer"><code>Ripserer.ripserer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ripserer(Type{&lt;:AbstractFiltration}, args...; kwargs...)
ripserer(filtration::AbstractFiltration; kwargs...)</code></pre><p>Compute the persistent homology of a filtration. The filtration can be given as an <a href="../extensions/#Ripserer.AbstractFiltration"><code>AbstractFiltration</code></a> type, followed by its arguments, or as an initialized object (see examples below). If only data is given, <code>Rips</code> is used by default.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>dim_max</code>: compute persistent homology up to this dimension. Defaults to <code>1</code>.</p></li><li><p><code>modulus</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>. Defaults to <code>2</code>.</p></li><li><p><code>field</code>: use this type of field of coefficients. Defaults to <a href="#Ripserer.Mod"><code>Ripserer.Mod</code></a><code>{modulus}</code>.</p></li><li><p><code>threshold</code>: compute persistent homology up to diameter smaller than threshold. This parameter is only applicable when using distance matrices or points as input. When using filtrations, threshold must be passed to the filtration constructor. Defaults to the radius of the input space. When using low thresholds with points or distance matrices, consider using <code>sparse=true</code>.</p></li><li><p><code>cutoff</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>. Defaults to <code>0</code>.</p></li><li><p><code>reps</code>: if <code>true</code>, attach representative (co)cycles to persistence intervals. Can also be set to collection of integers to only find representatives in specified dimensions, e.g. <code>reps=1:2</code> will only find representatives in dimensions 1 and 2. This is useful for large filtrations (such as cubical) where calculating zero-dimensional representatives can be very slow.  Defaults to <code>false</code> for cohomology and <code>1:dim_max</code> for homology.</p></li><li><p><code>verbose</code>: If <code>true</code>, show a verbose bar. Defaults to <code>false</code>.</p></li><li><p><code>alg</code>: select the algorithm used in computation. The options are:</p><ul><li><p><code>:cohomology</code>: Default and fastest algorithm. When <code>reps</code> is set, intervals are equipped with representative <em>co</em>cycles.</p></li><li><p><code>:homology</code>: Significantly slower than <code>:cohomology</code>, but finds representative cycles. Does not find infinite intervals beyond dimension 0.</p></li><li><p><code>:involuted</code>: Use cohomology result to compute representative cycles. Can be extremely efficient compared to <code>:homology</code>, especially with <code>Rips</code> filtrations. Unlike <code>:homology</code>, this algorithm finds infinite intervals.</p></li></ul></li><li><p><code>implicit</code>: If <code>true</code>, an implicit reduction algorithm is used. Defaults to <code>true</code> for :cohomology and <code>:involuted</code>, and <code>false</code> for <code>:homology</code>. <code>implicit=false</code> is not recommended for <code>:cohomology</code> because it disables the emergent pairs optimization.</p></li></ul><p>Other <code>kwargs...</code> are passed to the filtration.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ts = range(0, 2π; length=20)[1:(end - 1)];

julia&gt; X = [((2 + cos(θ)) * cos(φ), (2 + cos(θ)) * sin(φ), sin(θ)) for θ in ts for φ in ts];

julia&gt; ripserer(X)
2-element Array{PersistenceDiagramsBase.PersistenceDiagram,1}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(EdgeCollapsedRips, X; modulus=7, threshold=2)
2-element Array{PersistenceDiagramsBase.PersistenceDiagram,1}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(Rips(X; threshold=1); alg=:involuted)
2-element Array{PersistenceDiagramsBase.PersistenceDiagram,1}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/computation/ripserer.jl#L37-L113">source</a></section></article><h2 id="Filtrations"><a class="docs-heading-anchor" href="#Filtrations">Filtrations</a><a id="Filtrations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtrations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Rips" href="#Ripserer.Rips"><code>Ripserer.Rips</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rips{I, T} &lt;: AbstractRipsFiltration{I, T}</code></pre><p>This type represents a filtration of Vietoris-Rips complexes.</p><p>Diagonal items in the input matrix are treated as vertex birth times.</p><p>Zero values are not allowed due to how sparse matrices work in Julia. If you need zero birth times, try offseting all values by a constant.</p><p>Threshold defaults to the radius of the input space. When using low <code>threshold</code>s, consider using the <code>sparse=true</code> keyword argument. It will give the same result, but may be much faster.</p><p><strong>Constructors</strong></p><ul><li><code>Rips(distance_matrix; threshold=nothing)</code></li><li><code>Rips(points; metric=Euclidean(1e-12), threshold=nothing)</code></li><li><code>Rips{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)][1:end-1];

julia&gt; ripserer(Rips(data))
2-element Array{PersistenceDiagramsBase.PersistenceDiagram,1}:
 100-element 0-dimensional PersistenceDiagram
 1-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(Rips(data, threshold=1.7))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0628, ∞)

julia&gt; using Distances

julia&gt; ripserer(Rips(data, metric=Cityblock()))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0888, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/filtrations/rips.jl#L156-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cubical" href="#Ripserer.Cubical"><code>Ripserer.Cubical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cubical{T, K} &lt;: AbstractFiltration{CartesianIndex{K}, T}</code></pre><p><code>Cubical</code> is used to compute sublevel persistent homology on <code>N</code>-dimensional images, which are of type <code>AbstractArray{T, N}</code>.</p><p>This type uses the CubeMap structure to find birth times of cubes (see reference).</p><p><strong>Constructor</strong></p><ul><li><code>Cubical(image::AbstractArray{T, N}, threshold=maximum(image))</code></li></ul><p><strong>Reference</strong></p><p>Wagner, H., Chen, C., &amp; Vuçini, E. (2012). <a href="https://link.springer.com/chapter/10.1007/978-3-642-23175-9_7">Efficient computation of persistent homology for cubical data.</a> In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; image = [1 0 0; 0 2 0; 0 0 0];

julia&gt; ripserer(Cubical(image))[1]
1-element 0-dimensional PersistenceDiagram:
 [0.0, ∞)

julia&gt; ripserer(Cubical(image))[2]
1-element 1-dimensional PersistenceDiagram:
 [1.0, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/filtrations/cubical.jl#L118-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Custom" href="#Ripserer.Custom"><code>Ripserer.Custom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Custom{I, T} &lt;: AbstractCustomFiltration{I, T}</code></pre><p>Build a custom filtration by specifying simplices and their birth times.</p><p>The list of simplices is corrected to form a valid filtration; birth times are corrected so a simplex is never born before its faces and missing simplices are added.</p><p>See the examples below for construction. Note how the unlisted 0-simplices were added with birth times equal to the lowest between their cofaces. The order in which simplices are given does not matter.</p><p>To create your own types of custom filtrations, subtype <a href="../extensions/#Ripserer.AbstractCustomFiltration"><code>AbstractCustomFiltration</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; flt = Custom([(1,) =&gt; 0, (4,) =&gt; 0, (1, 2) =&gt; 1, (1, 3) =&gt; 2, (1, 4) =&gt; 3, (2, 3) =&gt; 4, (2, 4) =&gt; 5, (3, 4) =&gt; 6, (1, 2, 3) =&gt; 7, (1, 2, 4) =&gt; 8, (1, 3, 4) =&gt; 9]; threshold=8)
Custom{Int64, Int64}(nv=4)

julia&gt; flt[0] # Can be indexed with dimension to list simplices
4-element Array{Simplex{0,Int64,Int64},1}:
 +Simplex{0}((4,), 0)
 +Simplex{0}((2,), 1)
 +Simplex{0}((3,), 2)
 +Simplex{0}((1,), 0)

julia&gt; ripserer(flt)[1]
2-element 0-dimensional PersistenceDiagram:
 [0.0, 3.0)
 [0.0, ∞)

julia&gt; ripserer(flt)[2]
3-element 1-dimensional PersistenceDiagram:
 [5.0, 8.0)
 [4.0, 7.0)
 [6.0, ∞)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/filtrations/custom.jl#L57-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Alpha" href="#Ripserer.Alpha"><code>Ripserer.Alpha</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Alpha{I, P&lt;:SVector} &lt;: AbstractFiltration{I, Float64}</code></pre><p><code>Alpha</code> filtrations are filtrations of the Delaunay complex.</p><p>They have much fewer simplices than <code>Rips</code>, so they are efficient even with large datasets, as long as their dimensionality is low.  What &quot;low&quot; means depends on the data, but this is definitely a good choice for 3D or lower. For high dimensional data, filtration construction may take a long time.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike most implementations, this one uses circumdiameters instead of circumradii. This makes the scale of the results comparable to <code>Rips</code>. If you need radius based values, divide your data or the resulting interval endpoints by 2.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This filtration uses <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>. Please see the installation instructions if constructions cause errors. MiniQhull currently has problems running on Windows. See <a href="https://github.com/gridap/MiniQhull.jl/issues/5">this issue</a> for more info.</p></div></div><p><strong>Constructors</strong></p><ul><li><code>Alpha(points; threshold, verbose)</code>: <code>points</code> should be a vector of <code>Tuple</code>s, <code>SVector</code>s or similar.</li><li><code>Alpha{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices. Try using <code>I=Int128</code> if construction complains about overflow.</li></ul><p><strong>Reference</strong></p><p>Edelsbrunner, H. (1993, July). The union of balls and its dual shape. <a href="https://dl.acm.org/doi/abs/10.1145/160985.161139">In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231)</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = [(sin(t), cos(t), (t - π)^2) for t in range(0, 2π, length=101)[1:end-1]];

julia&gt; alpha = Alpha(data)
Alpha{Int64, Float64}(nv=100)

julia&gt; rips = Rips(data)
Rips{Int64, Float64}(nv=100, sparse=false)

julia&gt; length(Ripserer.edges(alpha))
197

julia&gt; length(Ripserer.edges(rips))
3613

julia&gt; sort(ripserer(alpha)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: Ripserer.Simplex{1,Float64,Int64}
 death_simplex: Ripserer.Simplex{2,Float64,Int64}

julia&gt; sort(ripserer(rips)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: Ripserer.Simplex{1,Float64,Int64}
 death_simplex: Ripserer.Simplex{2,Float64,Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/filtrations/alpha.jl#L130-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.EdgeCollapsedRips" href="#Ripserer.EdgeCollapsedRips"><code>Ripserer.EdgeCollapsedRips</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EdgeCollapsedRips{I, T} &lt;: AbstractRipsFiltration{I, T}</code></pre><p>Perform a sequence of edge collapses on a filtration. This may significantly reduce computation time and does not change the result. The speedup is especially apparent with datasets that have a boundary, and with high-dimensional persistent homology computation.</p><p>The drawback is that doing the collapses themselves can be time-consuming. The construction does not require a lot of memory (<span>$\mathcal{O}(n^2)$</span> for <span>$n$</span> vertices). This might still be a good choice for large inputs if you are willing to wait but don&#39;t have enough memory to compute persistent homology with <code>Rips</code>.</p><p>See the reference below for a description of the algorithm.</p><p><strong>Constructors</strong></p><ul><li><p><code>EdgeCollapsedRips(::AbstractRipsFiltration; verbose=false, threshold=nothing )</code>: Collapse a given filtration. Setting <code>verbose</code> shows a progress bar.</p></li><li><p><code>EdgeCollapsedRips(::EdgeCollapsedRips; verbose=false, threshold=nothing)</code>: Allows changing <code>I</code> or <code>threshold</code> without recomputing.</p></li><li><p><code>EdgeCollapsedRips(arg; kwargs...)</code>: Use <code>arg</code> and <code>kwargs</code> to construct a <code>Rips</code> filtration and collapse it</p></li><li><p><code>EdgeCollapsedRips{I}(arg; kwargs...)</code>: Change the index type used to represent simplices. May be necessary for large inputs and high-dimensional computation.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Random; Random.seed!(1337);

julia&gt; data = [tuple(rand(6)...) for _ in 1:100];

julia&gt; rips = Rips(data)
Rips{Int64, Float64}(nv=100, sparse=false)

julia&gt; length(Ripserer.edges(rips))
3906

julia&gt; collapsed = EdgeCollapsedRips(data) # or EdgeCollapsedRips(rips)
EdgeCollapsedRips{Int64, Float64}(nv=100)

julia&gt; length(Ripserer.edges(collapsed))
1419

julia&gt; ripserer(rips) == ripserer(collapsed)
true

julia&gt; ripserer(collapsed; dim_max=4)
5-element Array{PersistenceDiagramsBase.PersistenceDiagram,1}:
 100-element 0-dimensional PersistenceDiagram
 75-element 1-dimensional PersistenceDiagram
 37-element 2-dimensional PersistenceDiagram
 14-element 3-dimensional PersistenceDiagram
 1-element 4-dimensional PersistenceDiagram
</code></pre><p><strong>Reference</strong></p><p>Boissonnat, J. D., &amp; Pritam, S. (2019). <a href="https://hal.inria.fr/hal-02395227/">Edge Collapse and Persistence of Flag Complexes</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/filtrations/edgecollapse.jl#L128-L192">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Mod" href="#Ripserer.Mod"><code>Ripserer.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Mod{M} &lt;: Integer</code></pre><p><code>Mod{M}</code> is the default field used by Ripserer. It is a representation of a finite field <span>$\mathbb{Z}_M$</span>, integers modulo small, prime <code>M</code>. Supports field arithmetic and can be converted to integer with <code>Int</code>.</p><p>Its values are not comparable on purpose.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Mod{3}(5)
2 mod 3

julia&gt; Mod{3}(5) + 1
0 mod 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/base/primefield.jl#L36-L55">source</a></section></article><h2 id="Persistence-Diagrams"><a class="docs-heading-anchor" href="#Persistence-Diagrams">Persistence Diagrams</a><a id="Persistence-Diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Persistence-Diagrams" title="Permalink"></a></h2><p>See also: <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/api/">PersistenceDiagrams.jl API</a>. For convenience, Ripserer reexports the following:</p><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.birth-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.birth-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth(interval)</code></pre><p>Get the birth time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.death-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.death-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.death</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death(interval)</code></pre><p>Get the death time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.persistence-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.persistence-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.persistence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">persistence(interval)</code></pre><p>Get the persistence of <code>interval</code>, which is equal to <code>death - birth</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.representative-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.representative-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.representative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative(interval::PersistenceInterval)</code></pre><p>Get the representative (co)cycle attached to <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.birth_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.birth_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.birth_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical birth simplex of <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagramsBase.death_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagramsBase.death_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagramsBase.death_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">death_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical death simplex of <code>interval</code>, if it has one.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An infinite interval&#39;s death simplex is <code>nothing</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.barcode" href="#PersistenceDiagrams.barcode"><code>PersistenceDiagrams.barcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barcode(diagram)</code></pre><p>Plot the barcode plot of persistence diagram or multiple diagrams in a collection. The <code>infinity</code> keyword argument determines where the infinity line is placed. If unset, the function tries to use <code>threshold(diagram)</code>, or guess a good position to place the line at.</p></div></section></article><h2 id="Experimental-Features"><a class="docs-heading-anchor" href="#Experimental-Features">Experimental Features</a><a id="Experimental-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-Features" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.reconstruct_cycle" href="#Ripserer.reconstruct_cycle"><code>Ripserer.reconstruct_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reconstruct_cycle(filtration, interval[, t]; distances=distance_matrix(filtration))</code></pre><p>Reconstruct the shortest representative cycle for the first homology group of given <code>interval</code>. The optional argument <code>t</code> sets the time at which the cycle is to be computed. It defaults to interval birth time, which gives a cycle similar to a representative cycle computed from homology. In general, higher times will yield nicer cycles. <code>t</code> can be a simplex or a number.</p><p>The optional <code>distances</code> keyword argument can be used to change the distance matrix used for determining edge lengths.</p><p>This method uses the representative cocycle to compute the cycle. As such, the interval must include a representative. To get such an interval, run <code>ripserer</code> with the keyword argument <code>reps=true</code> or <code>reps=1</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is still experimental.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/extra/cycles.jl#L112-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Partition" href="#Ripserer.Partition"><code>Ripserer.Partition</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">module Partition</code></pre><p>This submodule contains the following partition functions to be used with circular coordinates.</p><ul><li><code>Partition.linear(r, d) = max(r - d, 0.0)</code></li><li><code>Partition.quadratic(r, d) = (max(r - d, 0.0))^2</code></li><li><code>Partition.exponential(r, d) = r - d &gt; 0 ? exp(r^2/(d^2 - r^2)) : 0.0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/extra/circularcoordinates.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.CircularCoordinates" href="#Ripserer.CircularCoordinates"><code>Ripserer.CircularCoordinates</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CircularCoordinates</code></pre><p>This <code>struct</code> implements Perea&#39;s sparse circular coordinates (see reference below).</p><p>The idea behind this method is that you pick a subset of your data set (also called landmarks), compute persistent cohomology on that subset, and use the result to construct circular coordinates on the whole data set.</p><p>For this to work correctly, you need the following.</p><ul><li>A set of landmarks that cover the points well. The default minmax sampling method is</li></ul><p>usually a good choice here.</p><ul><li>The persistence diagram on the landmarks must have an interval that is persistent enough.</li></ul><p>The circular coordinates returned are on the interval [0, 1). If you are looking for angles, make sure to multiply them by <code>2π</code>.</p><p>If you try to compute circular coordinates for a point that is not near any landmark, the result will be <code>missing</code>.</p><p><strong>Constructor</strong></p><p><code>CircularCoordinates([::AbstractFiltration, ]points, landmarks; kwargs...)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>points</code>: a vector of points. The <code>eltype</code> of this vector can be <code>Tuple</code>s, <code>SVector</code>s, or similar.</p></li><li><p><code>landmarks</code>: can be an integer, a vector of indices, or a vector of points. If set to an integer, it sets the number of landmarks to choose with maxmin sampling. If you are looking for non-sparse circular coordinates, use <code>landmarks=eachindex(points)</code>.</p></li><li><p><code>out_dim</code>: number of most persistent persistence intervals to use to compute coordinates. If less than <code>out_dim</code> suitable intervals are found, the construction will show a warning and construct <code>CircularCoordinates</code> with a lower <code>out_dim</code>. This warning can be suppressed by passing <code>warn=false</code>.</p></li><li><p><code>partition</code>: a function that defines the partition of unity used when determining the coordinates. Should take two arguments, <code>r</code>, the radius of the balls, and <code>d</code>, the distance from the landmark. The partition function should only have support on the ball around the landmark (in other words, it should evaluate to 0 when d ≥ r). If that is not the case, the circular coordinates are not well-defined and the results may not always make sense. See <a href="#Ripserer.Partition"><code>Partition</code></a> for a small collection of predefined functions.</p></li><li><p><code>metric</code>: a metric from <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a>. Can only be set if the filtration argument is <code>Rips</code>.</p></li><li><p><code>kwargs...</code>: additional keyword arguments passed to <code>ripserer</code>. Note that <code>modulus</code> is set to a random prime between 7 and 79 by default.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)[1:end-1]];

julia&gt; cc = CircularCoordinates(data, 1:10:100)
CircularCoordinates(
  out_dim=1,
  radius=(0.9510565162951535,),
  n_landmarks=10,
  partition=linear,
  metric=Distances.Euclidean(0.0),
)

julia&gt; summary(cc(data))
&quot;100×1 Array{Union{Missing, Float64},2}&quot;

julia&gt; summary(cc(data, 1))
&quot;100-element Array{Union{Missing, Float64},1}&quot;
</code></pre><p><strong>Reference</strong></p><p>Perea, J. A. (2020, June). Sparse circular coordinates via principal Z-bundles. In Topological Data Analysis: The Abel Symposium 2018 (Vol. 15, p. 435). Springer Nature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/aca4c10e34d5075106cc6021a0bf4133f67401f3/src/extra/circularcoordinates.jl#L132-L211">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../extensions/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 1 December 2020 22:50">Tuesday 1 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
