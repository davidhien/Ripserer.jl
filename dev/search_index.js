var documenterSearchIndex = {"docs":
[{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cocycles.jl\"","category":"page"},{"location":"generated/cocycles/#Representative-Cocycles","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"In this example, we will demonstrate how to compute and visualize representative cocycles of persistent homology generators.","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"As always, we start by importing the relevant packages.","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"using Ripserer\nusing Plots\ngr(); nothing # hide","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"We define a function that generates some data sampled from a curve.","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"function curve(n)\n    [(sin(t)+t/10, cos(t)+t/10) for t in range(0, 2π, length=n)]\nend\n\nplot(curve(100), legend=false, title=\"Curve\", aspect_ratio=1, xlab=\"x\", ylab=\"y\")","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"Then, we compute the persistent homology of that data with various numbers of points. We plot the representative cocycles of each result and turn them into an animation. This data set will always have at most one one-dimensional class. We invoke plot(interval, data) to plot the representative cocycle of the class. The same plot could be created by invoking representative(interval). We use the threshold_strict argument to only plot the simplices with diameter strictly lower than the death time of the interval.","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"anim = @animate for i in vcat(3:100, 100:-1:3)\n    points = curve(i)\n    res = ripserer(points, reps=true)\n\n    plt1 = plot(title=\"1-dimensional Representative Cocycle\",\n                xlab=\"x\",\n                ylab=\"y\",\n                legend=false,\n                ylim=(-0.8, 1.8),\n                aspect_ratio=1)\n    if length(res[2]) > 0\n        interval = res[2][1]\n        plot!(plt1, interval, points,\n              alpha=0.2,\n              linewidth=2,\n              threshold_strict=death(interval),\n              color=3)\n    end\n    scatter!(plt1, points, color=2)\n    plot(plt1, barcode(res), plot(res),\n         layout=@layout([a [b; c]]),\n         size=(800, 600))\nend\nmp4(anim, \"cocycles_anim.mp4\") # hide","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"We can save the animation by running the following.","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"mp4(anim, \"cocycles_anim.mp4\")","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"page"},{"location":"generated/cocycles/","page":"Representative Cocycles","title":"Representative Cocycles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/stability.jl\"","category":"page"},{"location":"generated/stability/#Stability","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"In this example we will demonstrate the stability of persistent homology. The stability theorem roughly states, that a small change in the input data will result in a small change in the resulting persistence diagram. In other words, persistent homology is very tolerant of noisy data. Also see the Distances example in PersistenceDiagrams.jl.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, start with loading some packages.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"As in the Basics example, we will look at the persistent homology of a noisy circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"function noisy_circle(n; r1=1, r2=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r1*sin(θ) + noise*rand() - noise/2,\n                       r2*cos(θ) + noise*rand() - noise/2))\n    end\n    points\nend","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We will look at the first persistent homology group of this space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"First, let's see what happens if we repeatedly sample 100 random points from a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_1.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We notice that an interval in H_1 always stands out and that its death remains constant. The only thing that changes is the birth time. The birth time is equal to the largest distance between adjacent points in the circle. At birth time, the circle is connected.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Now, let's add some noise!","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0.2)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_2.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"The interval is jumping around a lot more now, but it hovers around the same general area. It's still clearly the most persistent feature of our space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Next, let's look at how adding more and more noise affects the diagram.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for noise in vcat(0:0.01:1, 1:-0.01:0)\n    points = noisy_circle(100, noise=noise)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_3.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We see we have to add quite a bit of noise to destroy the diagram. Notice how the death time of the interval decreases as we add noise. This is the result of the diameter of the hole in our circle shrinking.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Finally, let's stretch our circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for r in vcat(0.0:0.02:2, 2:-0.02:0.0)\n    points = noisy_circle(100, noise=0.1, r1=r)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_4.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, we see the persistent homology stays stable, as long as the data at least somewhat resembles a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/malaria.jl\"","category":"page"},{"location":"generated/malaria/#Image-Classification-With-Cubical-Filtrations-and-Persistence-Images","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"In this example, we will show how to use Ripserer in an image classification context. Persistent homology is not a predictive algorithm, but it can be used to extract useful features from data.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"using Ripserer\nusing PersistenceDiagrams\nusing Images # also required: ImageIO to read .png files\nusing Plots\nusing ProgressMeter\nusing Random\nRandom.seed!(1337)\n\ndata_dir = joinpath(@__DIR__, \"../assets/data/malaria\") # replace with the correct path.\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's load the data. We will use a a data set with microscope images of healthy cells and cells infected with malaria. The original data set is quite large, but we can pretend we were only given 200 images to work with. We have chosen the 200 images randomly.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"uninfected = shuffle!(load.(readdir(joinpath(data_dir, \"uninfected\"), join=true)))\ninfected = shuffle!(load.(readdir(joinpath(data_dir, \"infected\"), join=true)))\n\nimages = [uninfected; infected]\nclasses = [fill(false, length(uninfected)); fill(true, length(infected))]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's see what the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(uninfected[1], title=\"Healthy\"),\n     plot(uninfected[2], title=\"Healthy\"),\n     plot(infected[1], title=\"Infected\"),\n     plot(infected[2], title=\"Infected\"))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"To make the images work with Ripserer, we convert them to floating gray scale values. We do not have to resize the images. Maybe some additional preprocessing, such as normalization would help, but we'll skip it for this example.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"inputs = [Gray.(image) for image in images]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now we can compute persistence diagrams. Since we are working with images, we have to use the Cubical filtration type. Cubical persistent homology should detect the dark spots (local minima) in the images. It's pretty efficient, so this should only take a few seconds.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"diagrams = @showprogress [ripserer(Cubical(i)) for i in inputs]","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"This is what some of the diagrams look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(images[1], title=\"Healthy\"), plot(diagrams[1]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(images[end], title=\"Infected\"), plot(diagrams[end]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Notice that there is a lot more going on in the middle of the infected diagram, especially in H_0.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"The persistence diagrams might look nice, but are hard to use with machine learning algorithms. The number of points in the diagram may be different for every image, even when images are of the same size. We can solve this problem by using a vectorization method, such as converting all diagrams to persistence images.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Persistence images work by weighting each point in the diagram with a distribution. The distribution defaults to a Gaussian, but any function of two arguments can be used. Each point is also weighted by a weighting function that should be equal to zero along the x-axis. It defaults to a function that is zero on the x-axis and linearly increases to the maximum persistence in the diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"We start by splitting the diagrams into their 0 and 1 dimensional components.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"dim_0 = first.(diagrams)\ndim_1 = last.(diagrams)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"We feed the diagram to the PersistenceImage constructor which will choose ranges that will fit all the diagrams. We set the sigma value to 0.1, since all persistence pairs are in the 0101 square and the default sigma of 1 would be too wide. We will use the default image size, which is 5×5.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"image_0 = PersistenceImage(dim_0, sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"image_1 = PersistenceImage(dim_1, sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's see how some of the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(dim_0[end], persistence=true),\n     heatmap(image_0(dim_0[end]), aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(dim_1[end], persistence=true),\n     heatmap(image_1(dim_1[end]), aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Next, we convert all diagrams to images and use vec to turn them into flat vectors. We then concatenate the zero and one-dimensional images. The result is a vector of length 50 for each diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"persims = [[vec(image_0(dim_0[i])); vec(image_1(dim_1[i]))]\n           for i in 1:length(diagrams)]","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now it's time to fit our model. We will use GLMNet.jl to fit a regularized linear model.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"using GLMNet","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Convert the image vectors to a matrix that will be understood by glmnet.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"X = reduce(hcat, persims)'\ny = classes\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Start by randomly splitting the data into two sets, a training and a testing set.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"perm = shuffle(1:200)\ntrain_x = X[perm[1:100], :]\ntrain_y = y[perm[1:100]]\ntest_x = X[perm[101:end], :]\ntest_y = y[perm[101:end]]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Fit the model and predict.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"path = glmnet(train_x, train_y)\ncv = glmnetcv(train_x, train_y)\n\nλ = path.lambda[argmin(cv.meanloss)]\npath = glmnet(train_x, train_y; lambda=[λ])\n\npredictions = .!iszero.(round.(GLMNet.predict(path, test_x)))\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Get the classification accuracy.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"accuracy = count(predictions .== test_y) / length(test_y)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Not half bad considering we haven't touched the images and we left pretty much all settings on default.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now let's look at the misclassified examples.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"missed = findall(predictions .!= test_y)\nlabel = (\"Healthy\", \"Infected\")\nplts = [plot(images[i],\n             title=\"$(label[test_y[i] + 1])\",\n             ticks=nothing)\n        for i in missed]\nplot(plts...)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Finally, let's look at which parts of the persistence images glmnet considered important.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(heatmap(reshape(path.betas[1:25], (5,5)), title=\"H₀ coefficients\"),\n     heatmap(reshape(path.betas[26:50], (5,5)), title=\"H₁ coefficients\"))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"These correspond to the area we identified at the beginning. Also note that in this case, the classifier does not care about H_1 at all.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/sublevelset.jl\"","category":"page"},{"location":"generated/sublevelset/#Sublevel-Set-Persistent-Homology","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"","category":"section"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"In this example, we will demonstrate computing sublevel set persistent homology of time series and image data. We will need the following packages.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"using Ripserer\nusing Images\nusing Plots\ngr() # hide\nusing Random\nRandom.seed!(1337)\nnothing # hide","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"We will use two data sets in this example. The first will be a curve:","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"n = 1000\nx = range(0, 1, length=n)\ncurve = sin.(2π * 5x) .* x\n\ncurve_plot = plot(curve, legend=false, title=\"Curve\")","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"The other will be the Event Horizon Telescope picture of a black hole. We will use a small, 240×240 pixel version of the image. Ripserer should have no problems with processing larger images, but this will work well enough for the purpose of this tutorial.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"blackhole_image = load(\n    joinpath(@__DIR__, \"../assets/data/240px-Black_hole_-_Messier_87_crop_max_res.jpg\")\n)\nblackhole_plot = plot(blackhole_image, title=\"Black Hole\")","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"In order to use the image with Ripserer, we have to convert it to grayscale.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"blackhole = Gray.(blackhole_image)\nnothing # hide","category":"page"},{"location":"generated/sublevelset/#One-dimensional-Case","page":"Sublevel Set Persistent Homology","title":"One-dimensional Case","text":"","category":"section"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Sublevel set persistent homology provides a stable description of the critical points of a function. The zeroth persistent homology group H_0 corresponds to its local minima. To compute this with Ripserer, we use cubical persistent homology. Note that there is no information in H_1, since the function is one-dimensional, so we only grab the first part of the result.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result, _ = ripserer(Cubical(curve))\nplot(curve_plot, plot(result))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"To see which minimum each interval corresponds to, we compute representatives by setting reps=true.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result, _ = ripserer(Cubical(curve), reps=true)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"The infinite interval's representative will include the whole function. To plot a representative, simply pass the interval along with the data to plot. An alternative way to plot the same thing is to get the representative of the interval first and then plot that in the same way. Let's use both ways in the following example.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"infinite_interval = only(filter(!isfinite, result))\nplt = plot(representative(infinite_interval), curve,\n           legend=false,\n           title=\"Representatives\",\n           seriestype=:path)\n\nfor interval in filter(isfinite, result)\n    plot!(plt, interval, curve, seriestype=:path)\nend","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"To get the locations of the minima, extract the critical simplices from intervals. Since simplices act like collections of vertex indices, and zero-dimensional representatives have a single point each, we can use only to extract them. Cubical simplices store vertices as CartesianIndex, so we need to index into the x-values with them in order to plot them.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"min_indices = [only(birth_simplex(int)) for int in result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(plt, min_x, curve[min_x], color=1:6, markershape=:star)\nplot(plt, plot(result, markercolor=1:6, markeralpha=1))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Note that each interval's birth is equal to the value of the corresponding local minimum and its death is equal to the higher of the two adjacent maxima. An intuitive way of thinking about the result is imagining you pour water in the curve. Water is collected in a valley and once it reaches a local maximum, it starts pouring in the adjacent valley.","category":"page"},{"location":"generated/sublevelset/#Dealing-With-Noise","page":"Sublevel Set Persistent Homology","title":"Dealing With Noise","text":"","category":"section"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Let's add some noise to the curve from earlier and try to repeat the example.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"noisy_curve = curve .+ rand(length(curve))\nplot(noisy_curve)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Compute the persistence diagram and plot it. The persistence argument to plot plots the diagram in birth, persistence coordinates, which will make the level of noise easier to see.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"noisy_result, _ = ripserer(Cubical(noisy_curve), reps=true)\nplot(noisy_result, persistence=true)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"We can see a lot of noise in the diagram, but notice how all of it is below 1, which is exactly the amount we added. We can filter this out by supplying the cutoff argument to ripserer. This will ignore all intervals below this cutoff.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"filtered_result, _ = ripserer(Cubical(noisy_curve), reps=true, cutoff=1)\nplot(filtered_result, persistence=true)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"We could achieve the same result by simply filtering the resulting diagram.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"@assert filter(int -> persistence(int) > 1, noisy_result) == filtered_result # hide\nfilter(int -> persistence(int) > 1, noisy_result) == filtered_result","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Keep in mind, however, that for very large diagrams, collecting representatives on all of the noise could make ripserer much run slower. In that case, it is recommended to use cutoff, rather than filtering.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Now we can repeat what we did earlier.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"infinite_interval = only(filter(!isfinite, filtered_result))\nplt = plot(representative(infinite_interval), noisy_curve,\n           legend=false,\n           title=\"Representatives\",\n           seriestype=:path)\n\nfor interval in filter(isfinite, filtered_result)\n    plot!(plt, interval, noisy_curve, seriestype=:path)\nend\n\nmin_indices = [first(birth_simplex(int)) for int in filtered_result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(plt, min_x, noisy_curve[min_x], color=eachindex(filtered_result), markershape=:star)\nplot(plt, plot(filtered_result, markercolor=eachindex(filtered_result), markeralpha=1))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"The result we got is very similar even though the data set was very noisy.","category":"page"},{"location":"generated/sublevelset/#Two-dimensional-Case","page":"Sublevel Set Persistent Homology","title":"Two-dimensional Case","text":"","category":"section"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Now let's do a similar thing for a 2d example. There is nothing stopping us from going into higher dimensions, but we will skip those. The principles are exactly the same. Instead of looking for local minima, let's look for local maxima. To do that, we have to invert the image.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result = ripserer(Cubical(-blackhole))\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"We notice there are quite a lot of intervals along the diagonal. These correspond to local geometry of the image, so we are not interested in them right now. To filter them out, we set a cutoff.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1)\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Like earlier, we can show the local extrema in the image. We will show a different way to plot them. Let's use the threshold argument with plot, which only keeps parts of the representative with a diameter equal to or lower than threshold. If we needed a strict <, we could use threshold_strict.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1, reps=true)\nplt = plot(blackhole_image, title=\"Black Hole\")\nfor interval in result[1]\n    plot!(plt, interval, blackhole, threshold=birth(interval))\nend\nplot(plt, plot(result[1], markercolor=2:3, markeralpha=1))","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Some maxima have multiple values because more than one pixel in the image has the same value. Using birth_simplex instead of plotting the filtered representative would only show one of each.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Unlike with the previous example, we now also have access to H_1, which corresponds to the cycles in the image. Let's try to plot the representative of H_1.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"plt = plot(blackhole_image, title=\"Black Hole\")\nplot!(plt, only(result[2]), blackhole, label=\"H₁ cocycle\", color=1)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"Notice that the result is not actually a cycle, but rather a collection of pixels that would destroy the cycle if removed. The reason is that Ripserer computes persistent cohomology by default. The persistence diagrams of persistent homology and persistent cohomology are the same, but persistent cohomology is much more efficient to compute. The representatives it finds, however, tend to not be as informative. Keep this in mind when trying persistent homology out for larger datasets; it can take a very very long time. This case is quite small and computing persistent homology should pose no problem. We compute persistent homology with the argument cohomology=false.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"warning: Infinite Intervals in Persistent Homology\nRipserer currently can't compute infinite intervals in dimensions higher than zero with persistent homology.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1, reps=true, cohomology=false)\nplot!(plt, only(result[2]), blackhole, label=\"H₁ cycle\", color=3)","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"We have successfully found the hole in a black hole.","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"","category":"page"},{"location":"generated/sublevelset/","page":"Sublevel Set Persistent Homology","title":"Sublevel Set Persistent Homology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/ripserer/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/ripserer/#Ripserer","page":"Public API","title":"Ripserer","text":"","category":"section"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"ripserer","category":"page"},{"location":"api/ripserer/#Ripserer.ripserer","page":"Public API","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix; kwargs...)\nripserer(points; metric=Distances.Euclidean(), births, kwargs...)\nripserer(filtration::AbstractFiltration; kwargs...)\n\nCompute the persistent homology of metric space represented by dists, points and metric or a Ripserer.AbstractFiltration.\n\nIf using points, points must be an array of isbits types, such as NTuples or SVectors.\n\nKeyoword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nfield_type: use this type of field of coefficients. Defaults to Ripserer.Mod{modulus}.\nthreshold: compute persistent homology up to diameter smaller than threshold. For non-sparse Rips filtrations, it defaults to radius of input space.\ncutoff: only keep intervals with persistence(interval) > cutoff. Defaults to 0.\nreps: if true, return representative cocycles along with persistence intervals. Defaults to false.\nprogress: If true, show a progress bar. Defaults to false.\nmetric: when calculating persistent homology from points, any metric from Distances.jl can be used. Defaults to Distances.Euclidean().\ncohomology: if set to false, compute persistent homology instead of cohomology. This is much slower and gives the same result, but may give more informative representatives when reps is set to true. Currently unable to compute infinite intervals in dimensions higher than 0. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"Rips","category":"page"},{"location":"api/ripserer/#Ripserer.Rips","page":"Public API","title":"Ripserer.Rips","text":"Rips{I, T} <: AbstractRipsFiltration{I, T}\n\nThis type represents a filtration of Vietoris-Rips complexes. Diagonal items are treated as vertex birth times.\n\nThreshold defaults to radius of input space.\n\nConstructors\n\nRips(distance_matrix; threshold=nothing)\nRips(points; metric=Euclidean(), threshold=nothing)\nRips{I}(args...): I sets the size of integer used to represent simplices.\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"SparseRips","category":"page"},{"location":"api/ripserer/#Ripserer.SparseRips","page":"Public API","title":"Ripserer.SparseRips","text":"SparseRips{I, T} <: AbstractRipsFiltration{T, Simplex}\n\nThis type represents a sparse filtration of Vietoris-Rips complexes. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as missing. Diagonal items are treated as vertex birth times.\n\nConstructor\n\nSparseRips{I}(distance_matrix; threshold=nothing)\nSparseRips(distance_matrix; threshold=nothing): I sets the integer size used to represent simplices.\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"Cubical","category":"page"},{"location":"api/ripserer/#Ripserer.Cubical","page":"Public API","title":"Ripserer.Cubical","text":"Cubical{T, K} <: AbstractFiltration{CartesianIndex{K}, T}\n\nCubical is used to compute sublevel persistent homology on N-dimensional images, which are of type AbstractArray{T, N}.\n\nThis type uses the CubeMap structure to find birth times of cubes (see reference).\n\nConstructor\n\nCubical(image::AbstractArray{T, N}, threshold=maximum(image))\n\nReference\n\nWagner, H., Chen, C., & Vuçini, E. (2012). Efficient computation of persistent homology for cubical data. In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"Mod","category":"page"},{"location":"api/ripserer/#Ripserer.Mod","page":"Public API","title":"Ripserer.Mod","text":"Mod{M} <: Integer\n\nRepresentation of finite field mathbbZ_M, integers modulo small, prime M. Supports field arithmetic and can be converted to integer with Int.\n\nIs not comparable on purpose.\n\nExample\n\nMod{3}(5)\n\n# output\n\n2 mod 3\n\nMod{3}(5) + 1\n\n# output\n\n0 mod 3\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/#Simplices","page":"Public API","title":"Simplices","text":"","category":"section"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"Simplex","category":"page"},{"location":"api/ripserer/#Ripserer.Simplex","page":"Public API","title":"Ripserer.Simplex","text":"Simplex{D, T, I<:Integer} <: AbstractSimplex{D, T, I}\n\nThe vanilla simplex type represented by dimension D and index of type I and a birth time of type T.\n\nConstructor\n\nSimplex{D[, T, I]}(::I, ::T)\n\nExamples\n\nSimplex{2}(2, 1)\n\n# output\n\n2-dim Simplex{2}(2, 1):\n  +[4, 2, 1]\n\nSimplex{10}(Int128(-10), 1.0)\n\n# output\n\n4-dim Simplex{3}(1.0, 10, 2):\n  -Int128[12, 11, 10, 9, 8, 7, 6, 5, 4, 2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"Cube","category":"page"},{"location":"api/ripserer/#Ripserer.Cube","page":"Public API","title":"Ripserer.Cube","text":"Cubelet{D, T, K} <: AbstractSimplex{D, T, CartesianIndex{K}}\n\nA Cube is similar to a Simplex, but it has 2^D vertices instead of D+1. The vertices are encoded as the position in the CubeMap.\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"vertices","category":"page"},{"location":"api/ripserer/#Ripserer.vertices","page":"Public API","title":"Ripserer.vertices","text":"vertices(simplex::AbstractSimplex{dim, T, I})\n\nGet the vertices of simplex. Returns SVector{length(simplex), I}. When index(simplex) is an interger, a default implementation is provided.\n\nvertices(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n3-element StaticArrays.SArray{Tuple{3},Int64,1,3} with indices SOneTo(3):\n 3\n 2\n 1\n\n\n\n\n\n\nvertices(::AbstractFiltration)\n\nReturn the vertices in filtration. Defaults to 1:n. The eltype of the result can be anything as long as result[result[i]] == result[i] holds.\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"dim","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.dim","page":"Public API","title":"PersistenceDiagrams.dim","text":"dim(::PersistenceDiagram)\n\nGet the dimension of persistence diagram.\n\n\n\n\n\ndim(::AbstractSimplex)\ndim(::Type{<:AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\ndim(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n2\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/#Persistence-Diagrams","page":"Public API","title":"Persistence Diagrams","text":"","category":"section"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"See also: PersistenceDiagrams.jl API. Ripserer reexports the following:","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.birth","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.death","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.persistence","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.representative","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.birth_simplex","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.death_simplex","category":"page"},{"location":"api/ripserer/","page":"Public API","title":"Public API","text":"PersistenceDiagrams.barcode","category":"page"},{"location":"api/simplices/#Simplex-Interface","page":"Simplex Interface","title":"Simplex Interface","text":"","category":"section"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"Ripserer.AbstractSimplex","category":"page"},{"location":"api/simplices/#Ripserer.AbstractSimplex","page":"Simplex Interface","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, T, I} <: AbstractVector{I}\n\nAn abstract type for representing simplices. A simplex must have a diameter of type T, which is its birth time. The dimension must be encoded in the type as D and can be accessed by dim.\n\nThe simplex is expected to act like an array of indices of type I, but this is not actually needed for the main algorithm.\n\nInterface\n\nAbstractSimplex{D}(::SVector{<:Any, <:Integer}, ::T)\nbirth(::AbstractSimplex)\nindex(::AbstractSimplex)\nsign(::AbstractSimplex)\ncoboundary(::Any, ::AbstractSimplex)\nboundary(::Any, ::AbstractSimplex)\nvertices(::AbstractSimplex)\nBase.:-(::AbstractSimplex)\n\n\n\n\n\n","category":"type"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"dim(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"PersistenceDiagrams.dim","text":"dim(::AbstractSimplex)\ndim(::Type{<:AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\ndim(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n2\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"birth(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"PersistenceDiagrams.birth","text":"birth(simplex::AbstractSimplex)\n\nGet the birth time of simplex, i.e. the time it appears in a filtration.\n\nbirth(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n3.2\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"index(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.index-Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Ripserer.index","text":"index(simplex::AbstractSimplex)\n\nGet the combinatorial index of the simplex. The index can be any type, but should uniquely identify a simplex. It is also used to break ties when comparing simplices with the same birth time.\n\nindex(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n1\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"Base.sign(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Base.sign-Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Base.sign","text":"sign(simplex::AbstractSimplex)\n\nGet the orientation of simplex. Should return -1 or 1.\n\nsign(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n+1\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"Base.:-(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Base.:--Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Base.:-","text":"-(simplex::AbstractSimplex)\n\nReverse the simplex orientation.\n\n-Simplex{2}((3, 2, 1), 3.2)\n\n# output\n\n2-dim Simplex(1, 1):\n  -[3, 2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"vertices(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.vertices-Tuple{Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Ripserer.vertices","text":"vertices(simplex::AbstractSimplex{dim, T, I})\n\nGet the vertices of simplex. Returns SVector{length(simplex), I}. When index(simplex) is an interger, a default implementation is provided.\n\nvertices(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n3-element StaticArrays.SArray{Tuple{3},Int64,1,3} with indices SOneTo(3):\n 3\n 2\n 1\n\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"Ripserer.coboundary(::Any, ::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.coboundary-Tuple{Any,Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the coboundary of simplex by decreasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nIf all_cofacets is false, only return cofaces with vertices added to the beginning of vertex list. The method with all_cofacets only has to be implemented if the filtration does not overload columns_to_reduce.\n\nComes with a default implementation.\n\nWarning\n\nIf cofacets are not returned in decreasing index, the algorithm will not work correctly.\n\nExample\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor c in coboundary(filtration, Simplex{1}(2, 1))\n    println(c)\nend\n\n# output\n\nSimplex{2}(+[4, 3, 1], 1)\nSimplex{2}(-[3, 2, 1], 1)\n\nfor c in coboundary(filtration, Simplex{1}(2, 1), Val(false))\n    println(c)\nend\n\n# output\n\n2-dim Simplex(1, 1):\n  +[4, 3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/","page":"Simplex Interface","title":"Simplex Interface","text":"Ripserer.boundary(::Any, ::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.boundary-Tuple{Any,Ripserer.AbstractSimplex}","page":"Simplex Interface","title":"Ripserer.boundary","text":"boundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the boundary of simplex by increasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nComes with a default implementation.\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor f in boundary(filtration, Simplex{2}(2, 1))\n    println(f)\nend\n\n# output\n\nSimplex{2}(+[2, 1], 1)\nSimplex{2}(-[4, 1], 1)\nSimplex{2}(+[4, 2], 1)\n\n\n\n\n\n","category":"method"},{"location":"#Ripserer.jl","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient computation of persistent homology.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is a pure Julia library for computing persistent homology based on the Ripser algorithm. Roughly speaking, persistent homology detects topological holes in data in a noise-resistant, stable way. If you are unfamiliar with persistent homology, I recommend reading this excellent introduction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Examples for further info.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ripserer was created by Matija Čufar. If you used this software in your project, or if you have any comments, questions or suggestions, feel free to contact me at matijacufar@gmail.com.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While this package is fully functional, it is still in development and should not be considered stable. Interfaces and internals may still change.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered. To install it, simply run the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(\"Ripserer\")","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer supports the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Vietoris-Rips persistent homology.\nSublevel set persistent homology for multidimensional image and time series data.\nCalculation of persistent homology with coefficients in any (possibly user defined) field with the default of mathbbZ_p for a prime p.\nSparse distance matrix and thresholding support.\nComputing representative cocycles of persistent cohomology.\nPlotting persistence diagrams, barcodes, matchings and representative cocycles.\nGeneric API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ripserer uses PersistenceDiagrams.jl to represent persistence diagrams. It reexports some basic functionality, but please see that package for more persistence diagram-related functions.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much like Ripser, Ripserer uses the following optimizations to achieve its speed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compute persistent cohomology.\nApply the clearing optimization.\nDon't store things that can be easily recomputed.\nSkip apparent and emergent persistence pairs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a detailed description of the algorithm, please see the Ulrich Bauer's article on Ripser.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to Ripser, within around 30%. Depending on the data set, one or the other may be faster. There are no official benchmarks, because I have found benchmarking on my computer or a CI system to be too unreliable.","category":"page"},{"location":"#Extending","page":"Home","title":"Extending","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. See the Filtration Interface and Simplex Interface API sections for more info. To see an example of an extension, check out the implementation of cubical simplices and filtrations in src/cubical.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have written an extension or have trouble implementing one, please open a pull request or an issue.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I would like to thank:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@ubauer for creating the original Ripser on which this project is based.\n@ctralie and @sauln for creating ripser.py which has been a source of inspiration.\nŽiga Virk, for giving ideas and helping with the theoretical side of things.","category":"page"},{"location":"api/filtrations/#Filtration-Interface","page":"Filtration Interface","title":"Filtration Interface","text":"","category":"section"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.AbstractFiltration","category":"page"},{"location":"api/filtrations/#Ripserer.AbstractFiltration","page":"Filtration Interface","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{I, T}\n\nA filtration is used to find the edges in filtration and to create simplices. An AbstractFiltration{I, T}'s simplex type is expected to return simplices of type <:AbstractSimplex{_, T, I}.\n\nInterface\n\nn_vertices(::AbstractFiltration)\nedges(::AbstractFiltration)\nsimplex_type(::AbstractFiltration, dim)\nsimplex(::AbstractFiltration, ::Val{dim}, vertices, sign)\nunsafe_simplex(::AbstractFiltration, ::Val{dim}, vertices, sign)\nunsafe_cofacet(::AbstractFiltration, simplex, vertices, vertex[, sign, edges])\nbirth(::AbstractFiltration, v)\nthreshold(::AbstractFiltration)\ncolumns_to_reduce(::AbstractFiltration)\nemergent_pairs(::AbstractFiltration)\npostprocess_interval(::AbstractFiltration, ::Any)\n\n\n\n\n\n","category":"type"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.n_vertices(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/filtrations/#Ripserer.n_vertices-Tuple{Ripserer.AbstractFiltration}","page":"Filtration Interface","title":"Ripserer.n_vertices","text":"n_vertices(::AbstractFiltration)\n\nReturn the number of vertices in filtration.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.edges(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/filtrations/#Ripserer.edges-Tuple{Ripserer.AbstractFiltration}","page":"Filtration Interface","title":"Ripserer.edges","text":"edges(::AbstractFiltration)\n\nGet edges (1-simplices) in filtration. Edges should be of type simplex_type(filtration, 1).\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.birth(::Ripserer.AbstractFiltration, ::Any)","category":"page"},{"location":"api/filtrations/#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractFiltration,Any}","page":"Filtration Interface","title":"PersistenceDiagrams.birth","text":"birth(::AbstractFiltration, v)\nbirth(::AbstractFiltration)\n\nGet the birth time of vertex v in filtration. Defaults to 0. When v is not given, return births in an array of same size as vertices(::AbstractFiltration).\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.threshold(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/filtrations/#PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}","page":"Filtration Interface","title":"PersistenceDiagrams.threshold","text":"threshold(::AbstractFiltration)\n\nGet the threshold of filtration. This is the maximum diameter a simplex in the filtration can have. Defaults to Inf.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.simplex_type","category":"page"},{"location":"api/filtrations/#Ripserer.simplex_type","page":"Filtration Interface","title":"Ripserer.simplex_type","text":"simplex_type(::Type{<:AbstractFiltration}, D)\nsimplex_type(::AbstractFiltration, D)\n\nReturn the D-dimensional simplex type in the filtration. Only the method for the type needs to be overloaded.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.simplex","category":"page"},{"location":"api/filtrations/#Ripserer.simplex","page":"Filtration Interface","title":"Ripserer.simplex","text":" simplex(::AbstractFiltration, ::Val{D}, vertices, sign=1)\n\nReturn D-simplex constructed from vertices with sign equal to sign. Return nothing if simplex is not in filtration. This function is safe to call with vertices that are out of order. Default implementation sorts vertices and calls unsafe_simplex.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.unsafe_simplex","category":"page"},{"location":"api/filtrations/#Ripserer.unsafe_simplex","page":"Filtration Interface","title":"Ripserer.unsafe_simplex","text":"unsafe_simplex(::AbstractFiltration, ::Val{D}, vertices, sign=1)\n\nReturn D-simplex constructed from vertices with sign equal to sign. Return nothing if simplex is not in filtration. The unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.unsafe_cofacet","category":"page"},{"location":"api/filtrations/#Ripserer.unsafe_cofacet","page":"Filtration Interface","title":"Ripserer.unsafe_cofacet","text":"unsafe_cofacet(filtration, simplex, cofacet_vertices, v, sign[, edges])\nunsafe_cofacet(::Type{S}, filtration, simplex, cofacet_vertices, v, sign[, edges])\n\nReturn cofacet of simplex with vertices equal to cofacet_vertices. v is the vertex that was added to construct the cofacet. In the case of sparse rips filtrations, an additional argument edges is used. edges is a vector that contains the weights on edges connecting the new vertex to old vertices. S is the simplex type which can be used for dispatch.\n\nThe unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\nDefault implementation uses unsafe_simplex.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.columns_to_reduce","category":"page"},{"location":"api/filtrations/#Ripserer.columns_to_reduce","page":"Filtration Interface","title":"Ripserer.columns_to_reduce","text":"columns_to_reduce(::AbstractFilration, prev_column_itr)\n\nList all columns to reduce in next dimension, possibly computing it from previous columns. Default implementation uses coboundary with the all cofacets parameter set to Val(false).\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.emergent_pairs","category":"page"},{"location":"api/filtrations/#Ripserer.emergent_pairs","page":"Filtration Interface","title":"Ripserer.emergent_pairs","text":"emergent_pairs(::AbstractFiltration)\n\nPerform the emergent pairs optimization. Default to returning true. Should be set to false for a filtration type that is unable to produce (co)boundary simplices in the correct order.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.postprocess_interval","category":"page"},{"location":"api/filtrations/#Ripserer.postprocess_interval","page":"Filtration Interface","title":"Ripserer.postprocess_interval","text":"postprocess_interval(::AbstractFiltration, interval)\n\nThis function is called on each resulting persistence interval. If returns nothing, the interval is skipped. The default implementation returns the unchanged interval.\n\n\n\n\n\n","category":"function"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.AbstractRipsFiltration","category":"page"},{"location":"api/filtrations/#Ripserer.AbstractRipsFiltration","page":"Filtration Interface","title":"Ripserer.AbstractRipsFiltration","text":"AbstractRipsFiltration{I<:Signed, T} <: AbstractFiltration{I, T}\n\nAn abstract Vietoris-Rips filtration. Its subtypes can overload dist and get the following default implementations.\n\nn_vertices\nedges\nsimplex_type\nsimplex\nunsafe_simplex\nunsafe_cofacet\n\n\n\n\n\n","category":"type"},{"location":"api/filtrations/","page":"Filtration Interface","title":"Filtration Interface","text":"Ripserer.dist","category":"page"},{"location":"api/filtrations/#Ripserer.dist","page":"Filtration Interface","title":"Ripserer.dist","text":"dist(::AbstractRipsFiltration, u, v)\ndist(::AbstractRipsFiltration)\n\nReturn the distance between vertices u and v. If the distance is somehow invalid, it may return missing instead. If u and v are not given, return the distance matrix.\n\n\n\n\n\n","category":"function"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/basics.jl\"","category":"page"},{"location":"generated/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In this example we will present the usage of Ripserer. We start by loading some packages.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/basics/#Basic-Usage","page":"Basics","title":"Basic Usage","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Let's start with a basic example, points randomly sampled from a noisy circle. We start by defining our sampling function.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"function noisy_circle(n; r=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r*sin(θ) + noise*rand(), r*cos(θ) + noise*rand()))\n    end\n    points\nend","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Next, we sample 100 points from the circle.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"circ_100 = noisy_circle(100)\nscatter(circ_100, aspect_ratio=1, legend=false, title=\"Noisy Circle\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply run the following. The dim_max argument sets the maximum dimension persistent homology is computed in.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_circ = ripserer(circ_100, dim_max=3)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"warning: Warning\nComputing Vietoris-Rips persistent homology in high dimensions for large numbers of points is computationally expensive and requires a large amount of memory. Be careful or you will run out of memory. On an ordinary computer, you can expect to compute one-dimensional persistent homology for datasets of a few thousand points and higher (2-3) dimensional persistent homology for datasets of a few hundred points. This, of course, depends on the data set itself.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"The result can be plotted as a persistence diagram.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_circ)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Or as a barcode.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"H_1, H_2 and H_3 in this plot are hard to see, because we have too many H_0 bars. We can plot only some of the diagrams.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"note: Note\nresult is just an array of persistence diagrams, so the zero-dimensional diagram is found at index 1.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ[2:end], linewidth=2)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We can plot a single diagram in the same manner.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ[3], linewidth=3)","category":"page"},{"location":"generated/basics/#Distance-Matrix-Inputs","page":"Basics","title":"Distance Matrix Inputs","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In the previous example, we got our result by passing a collection of points to ripserer.  Under the hood, the algorithm actually works with distance matrices. Let's define a distance matrix of the shortest paths on a regular icosahedron graph.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Icosahedron_graph.svg\" height=\"250\" width=\"250\">","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"icosahedron = [0 1 2 2 1 2 1 1 2 2 1 3;\n               1 0 3 2 1 1 2 1 2 1 2 2;\n               2 3 0 1 2 2 1 2 1 2 1 1;\n               2 2 1 0 3 2 1 1 2 1 2 1;\n               1 1 2 3 0 1 2 2 1 2 1 2;\n               2 1 2 2 1 0 3 2 1 1 2 1;\n               1 2 1 1 2 3 0 1 2 2 1 2;\n               1 1 2 1 2 2 1 0 3 1 2 2;\n               2 2 1 2 1 1 2 3 0 2 1 1;\n               2 1 2 1 2 1 2 1 2 0 3 1;\n               1 2 1 2 1 2 1 2 1 3 0 2;\n               3 2 1 1 2 1 2 2 1 1 2 0]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply feed the distance matrix to ripserer.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_icosa = ripserer(icosahedron, dim_max=2)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Because an icosahedron is topologically equivalent to a sphere, we got a single class in the second dimension.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_icosa[3]","category":"page"},{"location":"generated/basics/#Thresholding","page":"Basics","title":"Thresholding","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In our next example, we will show how to use thresholding to speed up computation. We start by defining a sampling function that generates n points from the square -44times-44 with a circular hole of radius 1 in the middle.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"function cutout(n)\n    points = NTuple{2, Float64}[]\n    while length(points) < n\n        x, y = (8rand() - 4, 8rand() - 4)\n        if x^2 + y^2 > 1\n            push!(points, (x, y))\n        end\n    end\n    points\nend","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We sample 2000 points from this space.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"cutout_2000 = cutout(2000)\nscatter(cutout_2000, markersize=1, aspect_ratio=1, legend=false, title=\"Cutout\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We calculate the persistent homology and time the calculation.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut = ripserer(cutout_2000)\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Notice that while there are many 1-dimensional classes, one of them stands out. This class represents the hole in the middle of our square. We can extract this interval by doing the following.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"most_persistent = sort(result_cut[2], by=persistence)[end]","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Notice the death time of this interval is around 1.83 and that no intervals occur after that time. This means that we could stop computing when we reach this time and the result should not change. Let's try it out!","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut_thresh_2 = ripserer(cutout_2000, threshold=2)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_2, title=\"Persistence Diagram, threshold=2\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Indeed, the result is exactly the same, but it took less than a third of the time to compute.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_cut_thresh_2 == result_cut","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"If we pick a threshold that is too low, we still detect the interval, but its death time becomes infinite.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut_thresh_1 = ripserer(cutout_2000, threshold=1)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_1, title=\"Persistence Diagram, threshold=1\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"This page was generated using Literate.jl.","category":"page"}]
}
