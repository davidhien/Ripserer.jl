var documenterSearchIndex = {"docs":
[{"location":"references/#Acknowledgments","page":"Acknowledgements and References","title":"Acknowledgments","text":"","category":"section"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"I would like to thank:","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"@ubauer for creating the original Ripser on which this project is based.\n@ctralie and @sauln for creating ripser.py which has been a source of inspiration.\nŽiga Virk, for giving ideas and helping with the theoretical side of things.","category":"page"},{"location":"references/#References","page":"Acknowledgements and References","title":"References","text":"","category":"section"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Bauer, U. (2019). Ripser: efficient computation of Vietoris-Rips persistence barcodes. arXiv preprint arXiv:1908.02518.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Kaji, S., Sudo, T., & Ahara, K. (2020). Cubical Ripser: Software for computing persistent homology of image and volume data. arXiv preprint arXiv:2005.12692.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Wagner, H., Chen, C., & Vuçini, E. (2012). Efficient computation of persistent homology for cubical data. In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Chen, C., & Kerber, M. (2011, March). Persistent homology computation with a twist. In Proceedings 27th European Workshop on Computational Geometry (Vol. 11, pp. 197-200).","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"De Silva, V., Morozov, D., & Vejdemo-Johansson, M. (2011). Persistent cohomology and circular coordinates. Discrete & Computational Geometry, 45(4), 737-759.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Zomorodian, A., & Carlsson, G. (2005). Computing persistent homology. Discrete & Computational Geometry, 33(2), 249-274.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Edelsbrunner, H. (1993, July). The union of balls and its dual shape. In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231).","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cubical.jl\"","category":"page"},{"location":"generated/cubical/#Cubical-Persistent-Homology","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"In this example, we will demonstrate computing sublevel set persistent homology of time series and image data. We will need the following packages.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"using Ripserer\nusing Images\nusing Plots\ngr() # hide\nusing Random\nRandom.seed!(1337)\nnothing # hide","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We will use two data sets in this example. The first will be a curve:","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"n = 1000\nx = range(0, 1, length=n)\ncurve = sin.(2π * 5x) .* x\n\ncurve_plot = plot(curve, legend=false, title=\"Curve\")","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The other will be the Event Horizon Telescope picture of a black hole. We will use a small, 240×240 pixel version of the image. Ripserer should have no problems with processing larger images, but this will work well enough for this tutorial.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"blackhole_image = load(\n    joinpath(@__DIR__, \"../assets/data/240px-Black_hole_-_Messier_87_crop_max_res.jpg\")\n)\nblackhole_plot = plot(blackhole_image, title=\"Black Hole\")","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To use the image with Ripserer, we have to convert it to grayscale.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"blackhole = Gray.(blackhole_image)\nnothing # hide","category":"page"},{"location":"generated/cubical/#One-dimensional-Case","page":"Cubical Persistent Homology","title":"One-dimensional Case","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Sublevel set persistent homology provides a stable description of the critical points of a function. The zeroth persistent homology group H_0 corresponds to its local minima. To compute this with Ripserer, we use cubical persistent homology. Note that there is no information in H_1, since the function is one-dimensional, so we only grab the first part of the result.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result, _ = ripserer(Cubical(curve))\nplot(curve_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To see which minimum each interval corresponds to, we compute representatives by setting reps=true.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result, _ = ripserer(Cubical(curve), reps=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The infinite interval's representative will include the whole function. To plot a representative, simply pass the interval along with the data to plot. An alternative way to plot the same thing is to get the representative of the interval first and then plot that in the same way. Let's use both ways in the following example.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"infinite_interval = only(filter(!isfinite, result))\nplt = plot(representative(infinite_interval), curve,\n           legend=false,\n           title=\"Representatives\",\n           seriestype=:path)\n\nfor interval in filter(isfinite, result)\n    plot!(plt, interval, curve, seriestype=:path)\nend","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To get the locations of the minima, extract the critical simplices from intervals. Since simplices act like collections of vertex indices, and zero-dimensional representatives have a single point each, we can use only to extract them. Cubical simplices store vertices as CartesianIndex, so we need to index into the x-values with them to plot them.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"min_indices = [only(birth_simplex(int)) for int in result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(plt, min_x, curve[min_x], color=1:6, markershape=:star)\nplot(plt, plot(result, markercolor=1:6, markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Note that each interval's birth is equal to the value of the corresponding local minimum and its death is equal to the higher of the two adjacent maxima. An intuitive way of thinking about the result is imagining you pour water in the curve. Water is collected in a valley and once it reaches a local maximum, it starts pouring in the adjacent valley.","category":"page"},{"location":"generated/cubical/#Dealing-With-Noise","page":"Cubical Persistent Homology","title":"Dealing With Noise","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Let's add some noise to the curve from earlier and try to repeat the example.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"noisy_curve = curve .+ rand(length(curve))\nplot(noisy_curve)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Compute the persistence diagram and plot it. The persistence argument to plot plots the diagram in birth, persistence coordinates, which will make the level of noise easier to see.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"noisy_result, _ = ripserer(Cubical(noisy_curve), reps=true)\nplot(noisy_result, persistence=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We can see a lot of noise in the diagram, but notice how all of it is below 1, which is exactly the amount we added. We can filter this out by supplying the cutoff argument to ripserer. This will ignore all intervals below this cutoff.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"filtered_result, _ = ripserer(Cubical(noisy_curve), reps=true, cutoff=1)\nplot(filtered_result, persistence=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We could achieve the same result by simply filtering the resulting diagram.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"@assert filter(int -> persistence(int) > 1, noisy_result) == filtered_result # hide\nfilter(int -> persistence(int) > 1, noisy_result) == filtered_result","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Keep in mind, however, that for very large diagrams, collecting representatives on all of the noise could make ripserer much run slower. In that case, it is recommended to use cutoff, rather than filtering.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Now we can repeat what we did earlier.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"infinite_interval = only(filter(!isfinite, filtered_result))\nplt = plot(representative(infinite_interval), noisy_curve,\n           legend=false,\n           title=\"Representatives\",\n           seriestype=:path)\n\nfor interval in filter(isfinite, filtered_result)\n    plot!(plt, interval, noisy_curve, seriestype=:path)\nend\n\nmin_indices = [first(birth_simplex(int)) for int in filtered_result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(plt, min_x, noisy_curve[min_x], color=eachindex(filtered_result), markershape=:star)\nplot(plt, plot(filtered_result, markercolor=eachindex(filtered_result), markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The result we got is very similar even though the data set was very noisy.","category":"page"},{"location":"generated/cubical/#Two-dimensional-Case","page":"Cubical Persistent Homology","title":"Two-dimensional Case","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Now let's do a similar thing for a 2d example. Nothing is stopping us from going into higher dimensions, but we will skip those. The principles are the same. Instead of looking for local minima, let's look for local maxima. To do that, we have to invert the image.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole))\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We notice there are quite a lot of intervals along the diagonal. These correspond to the local geometry of the image, so we are not interested in them right now. To filter them out, we set a cutoff.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1)\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Like earlier, we can show the local extrema in the image. We will show a different way to plot them. Let's use the threshold argument with plot, which only keeps parts of the representative with a diameter equal to or lower than threshold. If we needed a strict <, we could use threshold_strict.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1, reps=true)\nplt = plot(blackhole_image, title=\"Black Hole\")\nfor interval in result[1]\n    plot!(plt, interval, blackhole, threshold=birth(interval))\nend\nplot(plt, plot(result[1], markercolor=2:3, markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Some maxima have multiple values because more than one pixel in the image has the same value. Using birth_simplex instead of plotting the filtered representative would only show one of each.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Unlike in the previous example, we now also have access to H_1, which corresponds to the cycles in the image. Let's try to plot the representative of H_1.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"plt = plot(blackhole_image, title=\"Black Hole\")\nplot!(plt, only(result[2]), blackhole, label=\"H₁ cocycle\", color=1)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Notice that the result is not a cycle, but rather a collection of pixels that would destroy the cycle if removed. The reason is that Ripserer computes persistent cohomology by default. The persistence diagrams of persistent homology and persistent cohomology are the same, but persistent cohomology is much more efficient to compute. The representatives it finds, however, tend to not be as informative. Keep this in mind when trying persistent homology out for larger datasets; it can take a very very long time. This case is quite small and computing persistent homology should pose no problem. We compute persistent homology with the argument alg=:homology.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"warning: Infinite Intervals in Persistent Homology\nRipserer currently can't compute infinite intervals in dimensions higher than zero with persistent homology.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole), cutoff=0.1, reps=true, alg=:homology)\nplot!(plt, only(result[2]), blackhole, label=\"H₁ cycle\", color=3)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We have successfully found the hole in a black hole.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"related-work/#Related-Julia-Packages","page":"Related Julia Packages","title":"Related Julia Packages","text":"","category":"section"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"This section attempts to provide an overview of Julia packages implementing persistent homology. If you're trying to do something Ripserer is missing, one of these might have what you're looking for.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"This list is incomplete and only includes things I'm aware of. The descriptions are based on my (limited) experience with these packages.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"ComputationalHomology.jl uses a different, slower algorithm, but can do some things Ripserer can't such as Čech persistent homology and homology of CW complexes. The package is a part of TDA.jl, which also offers other topological data analysis tools like Mapper.\nEirene.jl uses a different algorithm based on matroids. A benefit of this algorithm is that it can recover persistent homology generators and a bunch of other data.\nRipser.jl my deprecated wrapper of the original C++ program. Very bare-bones and outdated. Runs a bit slower than Ripserer.\nSparips.jl this is a preprocessor that comes with a different wrapper of Ripser. The preprocessor allows you to compute persistent homology of very large datasets. Integrating it with Ripserer is on my TODO list.\nPersistentCohomology.jl does essentially the same thing, but with a different algorithm, that is orders of magnitude slower.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"If you are a developer of a persistent homology package not on this list, or any of the information here is incorrect, let me know or open a PR.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cocycles.jl\"","category":"page"},{"location":"generated/cocycles/#Cohomology,-Homology,-and-Representatives","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"In this section, we will show how Ripserer can be used to find critical simplices and representative (co)cycles.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"We start by loading some packages and generating some data.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"using LinearAlgebra\nusing Plots\nusing Ripserer\nusing Random\nRandom.seed!(1337)\ngr() # hide\nnothing # hide\n\nfunction annulus(n, r1=1, r2=2, offset=(0,0))\n    result = Tuple{Float64, Float64}[]\n    while length(result) < n\n        point = 2 * r2 * rand(2) .- r2\n        if r1 < norm(point) < r2\n            push!(result, (point[1] + offset[1], point[2] + offset[2]))\n        end\n    end\n    return result\nend\n\ndata = annulus(300)\n\nscatter(data, label=\"data\", markersize=2, aspect_ratio=1)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's start by taking a look at the persistence diagram.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram = ripserer(data)\nplot(diagram)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The diagram tells us that there is a persistent hole in the data, but tells us nothing about the location of the hole. Ripserer provides several methods to locate it. We'll start with the simplest.","category":"page"},{"location":"generated/cocycles/#Critical-simplices","page":"Cohomology, Homology, and Representatives","title":"Critical simplices","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The first option is to find the death simplex of the interval.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"We start by extracting the interval in question. Keep in mind that the diagrams are sorted by persistence, so the last element will always be the most persistent.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"most_persistent = diagram[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Notice that the interval has two simplices attached to it, the birth simplex and the death simplex. We can extract them with birth_simplex and death_simplex respectively.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"death_sx = death_simplex(most_persistent)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"A simplex acts just like an array of indices, so it can be used to index into the data.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"data[death_sx]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Ripserer also provides a Plots recipe for plotting simplices. It is invoked by passing the simplex and the data to plot. Not that only the edges of the simplices are plotted.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(death_sx, data; label=\"death simplex\")\nplot!(birth_simplex(diagram[2][end]), data; label=\"birth simplex\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The birth simplex is the simplex that first connects the hole. The death simplex is the simplex that fills the hole in.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"While the death simplex gives us a vague idea of where the hole is located, there are other methods available.","category":"page"},{"location":"generated/cocycles/#Representative-Cocycles","page":"Cohomology, Homology, and Representatives","title":"Representative Cocycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"By default, Ripserer computes persistent cohomology. The resulting diagrams of persistent homology and cohomology are the same, but computing cohomology is much more efficient. When computing persistent cohomology, we can tell Ripserer to also compute representative cocycles. This is controlled with the reps keyword argument.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's take a look at the most persistent cocycle of our data set.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram_cocycles = ripserer(data, reps=true)\nmost_persistent_co = diagram_cocycles[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Notice that now, the interval also has a representative attached. The representative is an array of pairs Simplex => value, where the value is the coefficient of the simplex. In reality, the type is different, but it acts exactly the same as a Pair.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"cocycle = representative(most_persistent_co)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The representative can be plotted in the same way as a simplex.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(cocycle, data; label=\"cocycle\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The cocycle is a collection of 1-simplices that, if removed, would break the cycle in our data set. This does not correspond to most people's intuitive understanding of a hole, but it can be useful in some situations. To find something more intuitive, we have to look to homology and its representative cycles.","category":"page"},{"location":"generated/cocycles/#Representative-Cycles","page":"Cohomology, Homology, and Representatives","title":"Representative Cycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Ripserer supports two algorithms for computing representative cocycles. One is computing persistent homology directly, and the other is involuted homology computation. Involuted homology computes cohomology first and then uses its result to recompute cycles. While this increases the running time somewhat, it is still usually much more efficient than computing persistent homology directly. The difference is especially large for filtrations where the number of simplices increases quickly with dimension, such as Vietoris-Rips filtrations.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Involuted homology is computed by passing the argument alg=:involuted to ripserer. If we wanted direct homology computation, we would use alg=:homology. The results for both cases are exactly the same.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's try it out. Note that invoking homology also turns on reps for dimensions one and higher.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram_cycles = ripserer(data, alg=:involuted)\nmost_persistent_ho = diagram_cycles[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"If an interval with a representative is passed to plot, the representative is plotted.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(most_persistent_ho, data; label=\"cycle\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The cycle is still not the prettiest, but it at least corresponds to a topological circle wound around the hole in the middle of the data set. Sometimes, the cycle will also have multiple connected components. All except one will be contractible at the time the cycle exists. To make the result look even better, we can try reconstructing the shortest representative cycle.","category":"page"},{"location":"generated/cocycles/#Reconstructed-Shortest-Cycles","page":"Cohomology, Homology, and Representatives","title":"Reconstructed Shortest Cycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This method uses information from the cocycle to reconstruct the shortest cycle. Essentially what the method does is that it picks an edge in the cocycle and connects it through the edges in the filtration at the specified time. A limitation of this method is that it only works for one-dimensional representatives.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Reconstruction is done on a per interval basis, as it would take a long time to reconstruct all cycles in large diagrams.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's start with a basic reconstruction.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"filtration = diagram_cocycles[2].filtration\nreconstructed_at_birth = reconstruct_cycle(filtration, most_persistent_co)\n\nscatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(reconstructed_at_birth, data; label=\"reconstruction\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This looks much nicer than the homology example, but could still use some improvement. To improve it, we can set a time at which to reconstruct the cycle.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As time goes on and more simplices are added to the filtration, the shapes of the shortest cycles change as well. The previous example was drawn at interval birth time, which is the default. Let's see what happens if we set the time to the interval midpoint.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"midpoint = (death(most_persistent_co) - birth(most_persistent_co))/2\nreconstructed_at_midpoint = reconstruct_cycle(filtration, most_persistent_co, midpoint)\n\nscatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(reconstructed_at_midpoint, data; label=\"reconstruction\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As an extreme case, let's look at what the cycle looks like right before its death.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data, label=\"data\", markersize=2, aspect_ratio=1)\nplot!(\n    reconstruct_cycle(filtration, most_persistent_co, death(most_persistent_co) - 0.01),\n    data;\n    label=\"reconstruction\",\n)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As the time nears the death time, the cycle gets closer to looking like the death simplex.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The following tables show benchmarks that compare Ripserer's performance with Ripser, Cubical Ripser, and Eirene.jl. The benchmarking code and more info about the datasets are available here.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmarks were performed on a laptop with an Intel(R) Core(TM) i5-4200U CPU @ 1.60GHz with 8GB of RAM.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We used BenchmarkTools.jl to perform the timing benchmarks and Valgrind's Massif tool to measure peak heap sizes (i.e. total memory footprint).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks were performed with Ripserer v0.15, master versions of Ripser (commit hash 286d369) and Cubical Ripser (commit hashes 6edb9c5 for 2D and a063dac for 3D), and Eirene v1.3.5.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The timings show the minimum time taken among five runs of the benchmark.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The heap sizes for Ripserer include the Julia runtime.","category":"page"},{"location":"benchmarks/#Comparison-with-Ripser","page":"Benchmarks","title":"Comparison with Ripser","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In this experiment, we performed benchmarks with the datasets presented in the Ripser article. We only used the datasets that we were able to run with less than 8GB memory. All datasets were parsed as Float32 as that is what Ripser supports. The time it takes to parse a file is included for both Ripser and Ripserer.","category":"page"},{"location":"benchmarks/#Dense-results","page":"Benchmarks","title":"Dense results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Ripser ratio Ripserer heap Ripser heap\no3_1024 1024 3 1.8 4.576 s 3.057 s 1.497 374.1 MiB 151.0 MiB\no3_4096 4096 3 1.4 151.527 s 76.177 s 1.989 4.7 GiB 4.1 GiB\ndragon2000 2000 1  3.133 s 2.833 s 1.106 316.7 MiB 296.8 MiB\nfract-r 512 2  22.807 s 19.482 s 1.171 2.2 GiB 2.0 GiB\nrandom16 50 2  8 ms 10 ms 0.803 111.1 MiB 1.1 MiB\nsphere_3_192 192 2  1.549 s 1.491 s 1.039 287.0 MiB 209.5 MiB","category":"page"},{"location":"benchmarks/#Sparse-results","page":"Benchmarks","title":"Sparse results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These benchmarks were performed with the sparse=true keyword argument.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Ripser ratio Ripserer heap Ripser heap\no3_1024 1024 3 1.8 3.036 s 3.057 s 0.993 418.2 MiB 151.0 MiB\no3_4096 4096 3 1.4 76.052 s 76.177 s 0.998 4.9 GiB 4.1 GiB\ndragon2000 2000 1  3.588 s 2.833 s 1.267 350.4 MiB 296.8 MiB\nfract-r 512 2  25.399 s 19.482 s 1.304 2.2 GiB 2.0 GiB\nrandom16 50 2  9 ms 10 ms 0.932 111.1 MiB 1.1 MiB\nsphere_3_192 192 2  1.734 s 1.491 s 1.163 288.5 MiB 209.5 MiB","category":"page"},{"location":"benchmarks/#Alpha-Rips","page":"Benchmarks","title":"Alpha-Rips","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These benchmarks were performed on sparse matrices that correspond to the 1-skeleta of Delaunay triangulations. The purpose of these is to show performance with very sparse inputs.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim Ripserer Ripser ratio Ripserer heap Ripser heap\nalpha_3_sphere_3000 3000 3 636 ms 789 ms 0.807 138.4 MiB 33.2 MiB\nalpha_torus_10_000 10000 2 872 ms 1.179 s 0.741 130.0 MiB 27.7 MiB\nalpha_5_sphere_1000 1000 5 49.431 s 46.707 s 1.058 387.2 MiB 202.0 MiB\nalpha_dragon_2000 2000 2 56 ms 76 ms 0.744 2.4 GiB 1.5 GiB\nalpha_4_sphere_2000 2000 4 5.844 s 6.203 s 0.942 110.9 MiB 33.2 MiB","category":"page"},{"location":"benchmarks/#Comparison-with-Cubical-Ripser","page":"Benchmarks","title":"Comparison with Cubical Ripser","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In these benchmarks, we used some of the datasets presented in the Cubical Ripser article. We limited the 2D image size to 1999×999 as the current master (commit hash 6edb9c5) version of 2D Cubical Ripser throws an assertion error for anything larger. We were also unable to perform 3D 256×256×256 image benchmarks due to Ripserer running out of memory. The eltype of all datasets is Float64, because that is what Cubical Ripser supports. When running Ripserer in the real world, it's a good idea to use the image's native data types. This will slightly reduce the memory footprint and increase performance.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim Ripserer Cubical Ripser ratio Ripserer heap Cubical Ripser heap\nlena512 262144 1 787 ms 299 ms 2.631 145.0 MiB 49.3 MiB\nbonsai128 2097152 2 31.151 s 14.733 s 2.114 514.4 MiB 186.7 MiB\nbonsai64 262144 2 2.875 s 2.996 s 0.96 280.6 MiB 1.3 GiB\nhead128 2097152 2 24.102 s 12.434 s 1.938 1.5 GiB 1.9 GiB\nlena1999x999 1997001 1 2.87 s 2.009 s 1.429 1.5 GiB 1.9 GiB","category":"page"},{"location":"benchmarks/#Comparison-with-Eirene","page":"Benchmarks","title":"Comparison with Eirene","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In these benchmarks, we compare Ripserer to Eirene.jl. Ripserer benchmarks were run with alg=:involuted, so this measures the time it takes to compute representative cycles.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Eirene ratio\ngcycle 100 3  6.231 s 24.158 s 0.258\nhiv 1088 1  1.824 s 7.774 s 0.235\ndragon1000 1000 1  575 ms 8.441 s 0.068\ncelegans 297 2  4.217 s 4.588 s 0.919\no3_1024 1024 3 1.8 5.735 s 8.314 s 0.69\nrandom16 50 7  8.577 s 7.688 s 1.116","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/malaria.jl\"","category":"page"},{"location":"generated/malaria/#Image-Classification-With-Cubical-Filtrations-and-Persistence-Images","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"In this example, we will show how to use Ripserer in an image classification context. Persistent homology is not a predictive algorithm, but it can be used to extract useful features from data.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"using Ripserer\nusing PersistenceDiagrams\nusing Images # also required: ImageIO to read .png files\nusing Plots\nusing ProgressMeter\nusing Random\nRandom.seed!(1337)\n\ndata_dir = joinpath(@__DIR__, \"../assets/data/malaria\") # replace with the correct path.\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's load the data. We will use a a data set with microscope images of healthy cells and cells infected with malaria. The original data set is quite large, but we can pretend we were only given 200 images to work with. We have chosen the 200 images randomly.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"uninfected = shuffle!(load.(readdir(joinpath(data_dir, \"uninfected\"), join=true)))\ninfected = shuffle!(load.(readdir(joinpath(data_dir, \"infected\"), join=true)))\n\nimages = [uninfected; infected]\nclasses = [fill(false, length(uninfected)); fill(true, length(infected))]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's see what the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(uninfected[1], title=\"Healthy\"),\n     plot(uninfected[2], title=\"Healthy\"),\n     plot(infected[1], title=\"Infected\"),\n     plot(infected[2], title=\"Infected\"))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"To make the images work with Ripserer, we convert them to floating gray scale values. We do not have to resize the images. Maybe some additional preprocessing, such as normalization would help, but we'll skip it for this example.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"inputs = [Gray.(image) for image in images]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now we can compute persistence diagrams. Since we are working with images, we have to use the Cubical filtration type. Cubical persistent homology should detect the dark spots (local minima) in the images. It's pretty efficient, so this should only take a few seconds.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"diagrams = @showprogress [ripserer(Cubical(i)) for i in inputs]","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"This is what some of the diagrams look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(images[1], title=\"Healthy\"), plot(diagrams[1]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(images[end], title=\"Infected\"), plot(diagrams[end]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Notice that there is a lot more going on in the middle of the infected diagram, especially in H_0.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"The persistence diagrams might look nice, but are hard to use with machine learning algorithms. The number of points in the diagram may be different for every image, even when images are of the same size. We can solve this problem by using a vectorization method, such as converting all diagrams to persistence images.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Persistence images work by weighting each point in the diagram with a distribution. The distribution defaults to a Gaussian, but any function of two arguments can be used. Each point is also weighted by a weighting function that should be equal to zero along the x-axis. It defaults to a function that is zero on the x-axis and linearly increases to the maximum persistence in the diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"We start by splitting the diagrams into their 0 and 1 dimensional components.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"dim_0 = first.(diagrams)\ndim_1 = last.(diagrams)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"We feed the diagram to the PersistenceImage constructor which will choose ranges that will fit all the diagrams. We set the sigma value to 0.1, since all persistence pairs are in the 0101 square and the default sigma of 1 would be too wide. We will use the default image size, which is 5×5.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"image_0 = PersistenceImage(dim_0, sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"image_1 = PersistenceImage(dim_1, sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Let's see how some of the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(dim_0[end], persistence=true),\n     heatmap(image_0(dim_0[end]), aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(plot(dim_1[end], persistence=true),\n     heatmap(image_1(dim_1[end]), aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Next, we convert all diagrams to images and use vec to turn them into flat vectors. We then concatenate the zero and one-dimensional images. The result is a vector of length 50 for each diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"persims = [[vec(image_0(dim_0[i])); vec(image_1(dim_1[i]))]\n           for i in 1:length(diagrams)]","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now it's time to fit our model. We will use GLMNet.jl to fit a regularized linear model.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"using GLMNet","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Convert the image vectors to a matrix that will be understood by glmnet.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"X = reduce(hcat, persims)'\ny = classes\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Start by randomly splitting the data into two sets, a training and a testing set.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"perm = shuffle(1:200)\ntrain_x = X[perm[1:100], :]\ntrain_y = y[perm[1:100]]\ntest_x = X[perm[101:end], :]\ntest_y = y[perm[101:end]]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Fit the model and predict.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"path = glmnet(train_x, train_y)\ncv = glmnetcv(train_x, train_y)\n\nλ = path.lambda[argmin(cv.meanloss)]\npath = glmnet(train_x, train_y; lambda=[λ])\n\npredictions = .!iszero.(round.(GLMNet.predict(path, test_x)))\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Get the classification accuracy.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"accuracy = count(predictions .== test_y) / length(test_y)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Not half bad considering we haven't touched the images and we left pretty much all settings on default.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Now let's look at the misclassified examples.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"missed = findall(predictions .!= test_y)\nlabel = (\"Healthy\", \"Infected\")\nplts = [plot(images[i],\n             title=\"$(label[test_y[i] + 1])\",\n             ticks=nothing)\n        for i in missed]\nplot(plts...)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"Finally, let's look at which parts of the persistence images glmnet considered important.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"plot(heatmap(reshape(path.betas[1:25], (5,5)), title=\"H₀ coefficients\"),\n     heatmap(reshape(path.betas[26:50], (5,5)), title=\"H₁ coefficients\"))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"These correspond to the area we identified at the beginning. Also note that in this case, the classifier does not care about H_1 at all.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Filtrations and Persistence Images","title":"Image Classification With Cubical Filtrations and Persistence Images","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/ripserer/#Public-API","page":"Public","title":"Public API","text":"","category":"section"},{"location":"api/ripserer/#Ripserer","page":"Public","title":"Ripserer","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"ripserer","category":"page"},{"location":"api/ripserer/#Ripserer.ripserer","page":"Public","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix; kwargs...)\nripserer(points; metric=Distances.Euclidean(1e-12), births, kwargs...)\nripserer(filtration::AbstractFiltration; kwargs...)\n\nCompute the persistent homology of metric space represented by dists, points and metric, or a Ripserer.AbstractFiltration.\n\nIf dists or points are given, the Rips filtration is used.\n\nIf using points, points must be an array of isbits types, such as NTuples or SVectors.\n\nKeyword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nfield_type: use this type of field of coefficients. Defaults to Ripserer.Mod{modulus}.\nthreshold: compute persistent homology up to diameter smaller than threshold. This parameter is only applicable when using distance matrices or points as input. When using filtrations, threshold must be passed to the filtration constructor. Defaults to the radius of the input space. When using low thresholds with points or distance matrices, consider using sparse=true.\ncutoff: only keep intervals with persistence(interval) > cutoff. Defaults to 0.\nreps: if true, attach representative (co)cycles to persistence intervals. Can also be set to collection of integers to only find representatives in specified dimensions, e.g. reps=1:2 will only find representatives in dimensions 1 and 2. This is useful for large filtrations (such as cubical) where calculating zero-dimensional representatives can be very slow.  Defaults to false for cohomology and 1:dim_max for homology.\nprogress: If true, show a progress bar. Defaults to false.\nmetric: when calculating persistent homology from points, any metric from Distances.jl can be used. Defaults to Distances.Euclidean(1e-12).\nalg: select the algorithm used in computation. The options are:\n:cohomology: Default and fastest algorithm. When reps is set, intervals are equipped with representative cocycles.\n:homology: Significantly slower than :cohomology, but finds representative cycles. Does not find infinite intervals beyond dimension 0.\n:involuted: Use cohomology result to compute representative cycles. Can be extremely efficient compared to :homology, especially with Rips filtrations. Unlike :homology, this algorithm finds infinite intervals.\nimplicit: If true, an implicit reduction algorithm is used. Defaults to true for :cohomology and :involuted, and false for :homology. implicit=false is not recommended for :cohomology because it disables the emergent pairs optimization.\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/#Filtrations","page":"Public","title":"Filtrations","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Rips","category":"page"},{"location":"api/ripserer/#Ripserer.Rips","page":"Public","title":"Ripserer.Rips","text":"Rips{I, T} <: AbstractRipsFiltration{I, T}\n\nThis type represents a filtration of Vietoris-Rips complexes.\n\nDiagonal items in the input matrix are treated as vertex birth times.\n\nZero values are not allowed due to how sparse matrices work in Julia. If you need zero birth times, try offseting all values by a constant.\n\nThreshold defaults to the radius of the input space. When using low thresholds, consider using the sparse=true keyword argument. It will give the same result, but may be much faster.\n\nConstructors\n\nRips(distance_matrix; threshold=nothing)\nRips(points; metric=Euclidean(1e-12), threshold=nothing)\nRips{I}(args...): I sets the size of integer used to represent simplices.\n\nExamples\n\njulia> data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)][1:end-1];\n\njulia> ripserer(Rips(data))\n2-element Array{PersistenceDiagrams.PersistenceDiagram,1}:\n 100-element 0-dimensional PersistenceDiagram\n 1-element 1-dimensional PersistenceDiagram\n\njulia> ripserer(Rips(data, threshold=1.7))[2]\n1-element 1-dimensional PersistenceDiagram:\n [0.0628, ∞)\n\njulia> using Distances\n\njulia> ripserer(Rips(data, metric=Cityblock()))[2]\n1-element 1-dimensional PersistenceDiagram:\n [0.0888, 2.0)\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Cubical","category":"page"},{"location":"api/ripserer/#Ripserer.Cubical","page":"Public","title":"Ripserer.Cubical","text":"Cubical{T, K} <: AbstractFiltration{CartesianIndex{K}, T}\n\nCubical is used to compute sublevel persistent homology on N-dimensional images, which are of type AbstractArray{T, N}.\n\nThis type uses the CubeMap structure to find birth times of cubes (see reference).\n\nConstructor\n\nCubical(image::AbstractArray{T, N}, threshold=maximum(image))\n\nReference\n\nWagner, H., Chen, C., & Vuçini, E. (2012). Efficient computation of persistent homology for cubical data. In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.\n\nExample\n\njulia> image = [1 0 0; 0 2 0; 0 0 0];\n\njulia> ripserer(Cubical(image))[1]\n1-element 0-dimensional PersistenceDiagram:\n [0.0, ∞)\n\njulia> ripserer(Cubical(image))[2]\n1-element 1-dimensional PersistenceDiagram:\n [1.0, 2.0)\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Custom","category":"page"},{"location":"api/ripserer/#Ripserer.Custom","page":"Public","title":"Ripserer.Custom","text":"Custom{I, T} <: AbstractCustomFiltration{I, T}\n\nBuild a custom filtration by specifying simplices and their birth times.\n\nThe list of simplices is corrected to form a valid filtration; birth times are corrected so a simplex is never born before its faces and missing simplices are added.\n\nSee the examples below for construction. Note how the unlisted 0-simplices were added with birth times equal to the lowest between their cofaces. The order in which simplices are given does not matter.\n\nTo create your own types of custom filtrations, subtype AbstractCustomFiltration.\n\nExamples\n\njulia> flt = Custom([(1,) => 0, (4,) => 0, (1, 2) => 1, (1, 3) => 2, (1, 4) => 3, (2, 3) => 4, (2, 4) => 5, (3, 4) => 6, (1, 2, 3) => 7, (1, 2, 4) => 8, (1, 3, 4) => 9]; threshold=8)\nCustom{Int64, Int64}(nv=4)\n\njulia> flt[0] # Can be indexed with dimension to list simplices\n4-element Array{Simplex{0,Int64,Int64},1}:\n +Simplex{0}([4], 0)\n +Simplex{0}([2], 1)\n +Simplex{0}([3], 2)\n +Simplex{0}([1], 0)\n\njulia> ripserer(flt)[1]\n2-element 0-dimensional PersistenceDiagram:\n [0.0, 3.0)\n [0.0, ∞)\n\njulia> ripserer(flt)[2]\n3-element 1-dimensional PersistenceDiagram:\n [5.0, 8.0)\n [4.0, 7.0)\n [6.0, ∞)\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Alpha","category":"page"},{"location":"api/ripserer/#Ripserer.Alpha","page":"Public","title":"Ripserer.Alpha","text":"Alpha{I, P<:SVector} <: AbstractFiltration{I, Float64}\n\nAlpha filtrations are filtrations of the Delaunay complex.\n\nThey have much fewer simplices than Rips, so they are efficient even with large datasets, as long as their dimensionality is low.  What \"low\" means depends on the data, but this is definitely a good choice for 3D or lower. For high dimensional data, filtration construction may take a long time.\n\nnote: Note\nUnlike most implementations, this one uses circumdiameters instead of circumradii. This makes the scale of the results comparable to Rips. If you need radius based values, divide your data or the resulting interval endpoints by 2.\n\nwarning: Warning\nThis filtration uses MiniQhull.jl. Please see the installation instructions if constructions cause errors. MiniQhull currently has problems running on Windows. See this issue for more info.\n\nConstructors\n\nAlpha(points; threshold, progress): points should be a vector of Tuples, SVectors or similar.\nAlpha{I}(args...): I sets the size of integer used to represent simplices. Try using I=Int128 if construction complains about overflow.\n\nReference\n\nEdelsbrunner, H. (1993, July). The union of balls and its dual shape. In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231).\n\nExample\n\njulia> data = [(sin(t), cos(t), (t - π)^2) for t in range(0, 2π, length=101)[1:end-1]];\n\njulia> alpha = Alpha(data)\nAlpha{Int64, Float64}(nv=100)\n\njulia> rips = Rips(data)\nRips{Int64, Float64}(nv=100, sparse=false)\n\njulia> length(Ripserer.edges(alpha))\n197\n\njulia> length(Ripserer.edges(rips))\n3613\n\njulia> sort(ripserer(alpha)[2], by=persistence)[end]\n[0.375, 2.01) with:\n birth_simplex: 2-element Ripserer.Simplex{1,Float64,Int64}\n death_simplex: 3-element Ripserer.Simplex{2,Float64,Int64}\n\njulia> sort(ripserer(rips)[2], by=persistence)[end]\n[0.375, 2.01) with:\n birth_simplex: 2-element Ripserer.Simplex{1,Float64,Int64}\n death_simplex: 3-element Ripserer.Simplex{2,Float64,Int64}\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/#Simplices","page":"Public","title":"Simplices","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Simplex","category":"page"},{"location":"api/ripserer/#Ripserer.Simplex","page":"Public","title":"Ripserer.Simplex","text":"Simplex{D, T, I<:Integer} <: AbstractSimplex{D, T, I}\n\nThe vanilla simplex type represented by dimension D, an index of type I, and a birth time of type T.\n\nConstructors\n\nSimplex{D[, T, I]}(index, birth)\nSimplex{D}(vertices, birth): vertices must be sorted descending. This constructor mainly exists for debugging purposes. Using simplex is usually the better option.\n\nExamples\n\njulia> Simplex{2}(2, 1)\n2-dimensional Simplex(index=2, birth=1):\n  +[4, 2, 1]\n\njulia> Simplex{10}(Int128(-10), 1.0)\n10-dimensional Simplex(index=10, birth=1.0):\n  -Int128[12, 11, 10, 9, 8, 7, 6, 5, 4, 2, 1]\n\njulia> Simplex{2}((5, 2, 1), 1)\n2-dimensional Simplex(index=5, birth=1):\n  +[5, 2, 1]\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Cube","category":"page"},{"location":"api/ripserer/#Ripserer.Cube","page":"Public","title":"Ripserer.Cube","text":"Cube{D, T, K} <: AbstractSimplex{D, T, CartesianIndex{K}}\n\nA Cube is similar to a Simplex, but it has 2^D vertices instead of D+1. The vertices are encoded as the position in the CubeMap (see reference in Cubical). A Cube's vertices are of type CartesianIndex{K}.\n\nExample\n\njulia> Cube{1}(CartesianIndex(1, 2), 1.0)\n1-dimensional Cube(index=CartesianIndex(1, 2), birth=1.0):\n  +CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(1, 2)]\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Ripserer.vertices(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/ripserer/#LightGraphs.vertices-Tuple{Ripserer.AbstractSimplex}","page":"Public","title":"LightGraphs.vertices","text":"vertices(simplex::AbstractSimplex{dim, T, I})\n\nGet the vertices of simplex. Returns SVector{length(simplex), I}. When index(simplex) is an interger, a default implementation is provided.\n\nExample\n\njulia> vertices(Simplex{2}((3, 2, 1), 3.2))\n3-element StaticArrays.SArray{Tuple{3},Int64,1,3} with indices SOneTo(3):\n 3\n 2\n 1\n\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Ripserer.birth(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractSimplex}","page":"Public","title":"PersistenceDiagrams.birth","text":"birth(simplex::AbstractSimplex)\n\nGet the birth time of simplex, i.e. the time it first appears in the filtration.\n\nExample\n\njulia> birth(Simplex{2}((3, 2, 1), 3.2))\n3.2\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Ripserer.dim(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractSimplex}","page":"Public","title":"PersistenceDiagrams.dim","text":"dim(::AbstractSimplex)\ndim(::Type{<:AbstractSimplex})\n\nGet the dimension of a simplex i.e. the value of D. Can also be called on the type.\n\nExamples\n\njulia> dim(Simplex{2}((3, 2, 1), 3.2))\n2\n\njulia> dim(Cube{3, Int, 4})\n3\n\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/#Fields","page":"Public","title":"Fields","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"Mod","category":"page"},{"location":"api/ripserer/#Ripserer.Mod","page":"Public","title":"Ripserer.Mod","text":"Mod{M} <: Integer\n\nMod{M} is the default field used by Ripserer. It is a representation of a finite field mathbbZ_M, integers modulo small, prime M. Supports field arithmetic and can be converted to integer with Int.\n\nIts values are not comparable on purpose.\n\nExample\n\njulia> Mod{3}(5)\n2 mod 3\n\njulia> Mod{3}(5) + 1\n0 mod 3\n\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/#Persistence-Diagrams","page":"Public","title":"Persistence Diagrams","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"See also: PersistenceDiagrams.jl API. For convenience, Ripserer reexports the following:","category":"page"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"birth(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.birth-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.birth","text":"birth(interval)\n\nGet the birth time of interval.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"death(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.death-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.death","text":"death(interval)\n\nGet the death time of interval.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"persistence(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.persistence-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.persistence","text":"persistence(interval)\n\nGet the persistence of interval, which is equal to death - birth.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"representative(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.representative-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.representative","text":"representative(interval::PersistenceInterval)\n\nGet the representative (co)cycle attached to interval, if it has one.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"birth_simplex(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.birth_simplex","text":"birth_simplex(interval::PersistenceInterval)\n\nGet the critical birth simplex of interval, if it has one.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"death_simplex(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}","page":"Public","title":"PersistenceDiagrams.death_simplex","text":"death_simplex(interval::PersistenceInterval)\n\nGet the critical death simplex of interval, if it has one.\n\nNote: an infinite interval's death simplex is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"barcode","category":"page"},{"location":"api/ripserer/#PersistenceDiagrams.barcode","page":"Public","title":"PersistenceDiagrams.barcode","text":"barcode(diagram)\n\nPlot the barcode plot of persistence diagram or multiple diagrams diagrams. The infinity keyword argument determines where the infinity line is placed. If unset, the function tries to use threshold(diagram) or guess a good position to place the line at.\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/#Experimental-Features","page":"Public","title":"Experimental Features","text":"","category":"section"},{"location":"api/ripserer/","page":"Public","title":"Public","text":"reconstruct_cycle","category":"page"},{"location":"api/ripserer/#Ripserer.reconstruct_cycle","page":"Public","title":"Ripserer.reconstruct_cycle","text":"reconstruct_cycle(filtration, interval[, t]; distances=distance_matrix(filtration))\n\nReconstruct the shortest representative cycle for the first homology group of given interval. The optional argument t sets the time at which the cycle is to be computed. It defaults to interval birth time, which gives a cycle similar to a representative cycle computed from homology. In general, higher times will yield nicer cycles. t can be a simplex or a number.\n\nThe optional distances keyword argument can be used to change the distance matrix used for determining edge lengths.\n\nThis method uses the representative cocycle to compute the cycle. As such, the interval must include a representative. To get such an interval, run ripserer with the keyword argument reps=true or reps=1.\n\nwarning: Warning\nThis feature is still experimental.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"api/extensions/#Filtration-Interface","page":"Interfaces","title":"Filtration Interface","text":"","category":"section"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.AbstractFiltration","category":"page"},{"location":"api/extensions/#Ripserer.AbstractFiltration","page":"Interfaces","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{I, T}\n\nA filtration is used to find the edges in filtration and to create simplices. An AbstractFiltration{I, T}'s simplex type is expected to return simplices of type <:AbstractSimplex{_, T, I}.\n\nInterface\n\nnv(::AbstractFiltration)\nedges(::AbstractFiltration)\nsimplex_type(::Type{AbstractFiltration}, dim)\nsimplex(::AbstractFiltration, ::Val{dim}, vertices, sign)\nunsafe_simplex(::AbstractFiltration, ::Val{dim}, vertices, sign)\nunsafe_cofacet(::AbstractFiltration, simplex, vertices, vertex, sign[, edges])\nbirths(::AbstractFiltration)\nthreshold(::AbstractFiltration)\ncolumns_to_reduce(::AbstractFiltration, ::Any)\nemergent_pairs(::AbstractFiltration)\npostprocess_diagram(::AbstractFiltration, ::Any)\n\n\n\n\n\n","category":"type"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.nv(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/extensions/#LightGraphs.nv-Tuple{Ripserer.AbstractFiltration}","page":"Interfaces","title":"LightGraphs.nv","text":"nv(::AbstractFiltration)\n\nReturn the number of vertices in filtration.\n\nExample\n\njulia> Ripserer.nv(Rips([1 1; 1 1]))\n2\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.edges(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/extensions/#LightGraphs.edges-Tuple{Ripserer.AbstractFiltration}","page":"Interfaces","title":"LightGraphs.edges","text":"edges(::AbstractFiltration)\n\nGet edges (1-simplices) in filtration. Edges should be of type simplex_type(filtration, 1).\n\nExample\n\njulia> Ripserer.edges(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2))\n3-element Array{Simplex{1,Int64,Int64},1}:\n +Simplex{1}([2, 1], 2)\n +Simplex{1}([3, 1], 1)\n +Simplex{1}([3, 2], 1)\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.births(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/extensions/#Ripserer.births-Tuple{Ripserer.AbstractFiltration}","page":"Interfaces","title":"Ripserer.births","text":"births(::AbstractFiltration)\n\nGet the birth times of vertices in filtration. Defaults to all births being 0. Must return array of the same shape as the filtration's vertices.\n\nExamples\n\njulia> flt = Rips([1 1 2; 1 0 1; 2 1 0]);\n\njulia> Ripserer.births(flt)\n3-element view(::Array{Int64,1}, 1:4:9) with eltype Int64:\n 1\n 0\n 0\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.threshold(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/extensions/#PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}","page":"Interfaces","title":"PersistenceDiagrams.threshold","text":"threshold(::AbstractFiltration)\n\nGet the threshold of filtration. This is the maximum diameter a simplex in the filtration can have. Defaults to Inf.\n\nExamples\n\njulia> threshold(Rips([0 2 1; 2 0 1; 1 1 0]))\n1\n\njulia> threshold(Cubical([1 1 2; 3 2 1; 0 0 0]))\n3\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.simplex_type","category":"page"},{"location":"api/extensions/#Ripserer.simplex_type","page":"Interfaces","title":"Ripserer.simplex_type","text":"simplex_type(::Type{<:AbstractFiltration}, D)\nsimplex_type(::AbstractFiltration, D)\n\nReturn the D-dimensional simplex type in the filtration. Only the method for the type needs to be overloaded.\n\nExamples\n\njulia> Ripserer.simplex_type(Rips{Int, Float64}, 1)\nSimplex{1,Float64,Int64}\n\njulia> Ripserer.simplex_type(Cubical{2, Float16}, 2)\nCube{2,Float16,2}\n\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.simplex","category":"page"},{"location":"api/extensions/#Ripserer.simplex","page":"Interfaces","title":"Ripserer.simplex","text":" simplex(::AbstractFiltration, ::Val{D}, vertices, sign=1)\n\nReturn D-simplex constructed from vertices with sign equal to sign. Return nothing if simplex is not in filtration. This function is safe to call with vertices that are out of order. Default implementation sorts vertices and calls unsafe_simplex.\n\nExample\n\njulia> simplex(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2), Val(1), (1, 2), -1)\n1-dimensional Simplex(index=1, birth=2):\n  -[2, 1]\n\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.unsafe_simplex","category":"page"},{"location":"api/extensions/#Ripserer.unsafe_simplex","page":"Interfaces","title":"Ripserer.unsafe_simplex","text":"unsafe_simplex(::AbstractFiltration, ::Val{D}, vertices, sign=1)\n\nReturn D-simplex constructed from vertices with sign equal to sign. Return nothing if simplex is not in filtration. The unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.unsafe_cofacet","category":"page"},{"location":"api/extensions/#Ripserer.unsafe_cofacet","page":"Interfaces","title":"Ripserer.unsafe_cofacet","text":"unsafe_cofacet(filtration, simplex, cofacet_vertices, v, sign[, edges])\nunsafe_cofacet(::Type{S}, filtration, simplex, cofacet_vertices, v, sign[, edges])\n\nReturn cofacet of simplex with vertices equal to cofacet_vertices. v is the vertex that was added to construct the cofacet. In the case of sparse rips filtrations, an additional argument edges is used. edges is a vector that contains the weights on edges connecting the new vertex to old vertices. S is the simplex type which can be used for dispatch.\n\nThe unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\nDefault implementation uses unsafe_simplex.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.columns_to_reduce","category":"page"},{"location":"api/extensions/#Ripserer.columns_to_reduce","page":"Interfaces","title":"Ripserer.columns_to_reduce","text":"columns_to_reduce(::AbstractFilration, prev_column_itr)\n\nList all columns to reduce in next dimension, possibly computing it from previous columns. Default implementation uses coboundary with the all cofacets parameter set to Val(false).\n\nExample\n\njulia> flt = Rips([0 1 1; 1 0 1; 1 1 0]);\n\njulia> Ripserer.columns_to_reduce(flt, Ripserer.edges(flt)) |> collect\n1-element Array{Simplex{2,Int64,Int64},1}:\n +Simplex{2}([3, 2, 1], 1)\n\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.emergent_pairs","category":"page"},{"location":"api/extensions/#Ripserer.emergent_pairs","page":"Interfaces","title":"Ripserer.emergent_pairs","text":"emergent_pairs(::AbstractFiltration)\n\nReturn true if the emergent pairs optimization is to be performed. Default to returning true. Should be set to false for a filtration type that is unable to produce (co)boundary simplices in the correct order.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.postprocess_diagram","category":"page"},{"location":"api/extensions/#Ripserer.postprocess_diagram","page":"Interfaces","title":"Ripserer.postprocess_diagram","text":"postprocess_diagram(::AbstractFiltration, diagram)\n\nThis function is called on each resulting persistence diagram after all intervals have been computed. Defaults to not doing anything.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.distance_matrix","category":"page"},{"location":"api/extensions/#Ripserer.distance_matrix","page":"Interfaces","title":"Ripserer.distance_matrix","text":"distance_matrix(::AbstractFiltration)\n\nReturn a matrix with distances between vertices of the filtration. These distances are used to determine edge length when finding shortest represenatative cycle in reconstruct_cycle.\n\nDefaults to all distances being 1.\n\nExamples\n\njulia> flt = Rips([1 1 2; 1 0 1; 2 1 0]);\n\njulia> Ripserer.distance_matrix(flt)\n3×3 Array{Int64,2}:\n 1  1  2\n 1  0  1\n 2  1  0\n\njulia> flt = Custom([(1,2,3,4) => 10.0, (1,2) => 3.0, (1,3) => 4.0, (2,3) => 5.0]);\n\njulia> Ripserer.distance_matrix(flt)\n4×4 Ripserer.DefaultDist{Float64}:\n 0.0  1.0  1.0  1.0\n 1.0  0.0  1.0  1.0\n 1.0  1.0  0.0  1.0\n 1.0  1.0  1.0  0.0\n\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.AbstractRipsFiltration","category":"page"},{"location":"api/extensions/#Ripserer.AbstractRipsFiltration","page":"Interfaces","title":"Ripserer.AbstractRipsFiltration","text":"AbstractRipsFiltration{I<:Signed, T} <: AbstractFiltration{I, T}\n\nAn abstract Vietoris-Rips filtration. Its subtypes can only overload adjacency_matrix and get default implementations for the rest of the filtration interface.\n\nExample\n\njulia> struct MyRips <: Ripserer.AbstractRipsFiltration{Int, Float16} end\n\njulia> Ripserer.adjacency_matrix(::MyRips) = [0 1 1; 1 0 1; 1 1 0]\n\njulia> ripserer(MyRips())\n2-element Array{PersistenceDiagrams.PersistenceDiagram,1}:\n 3-element 0-dimensional PersistenceDiagram\n 0-element 1-dimensional PersistenceDiagram\n\n\n\n\n\n\n","category":"type"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.AbstractCustomFiltration","category":"page"},{"location":"api/extensions/#Ripserer.AbstractCustomFiltration","page":"Interfaces","title":"Ripserer.AbstractCustomFiltration","text":"abstract type AbstractCustomFiltration{I, T} <: AbstractFiltration{I, T}\n\nThis abstract type is for filtrations that have all simplices stored in Dicts. The dicts should be accessible by the function simplex_dicts and should be a vector of Dict{I, T}. A custom filtration should also have adjacency_matrix defined. This matrix is only used as an adjacency matrix. Its values are ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.simplex_dicts","category":"page"},{"location":"api/extensions/#Ripserer.simplex_dicts","page":"Interfaces","title":"Ripserer.simplex_dicts","text":"simplex_dicts(::AbstractCustomFiltration)\n\nGet the dictionaries used to get simplex birth times. Should return a Vector of Dict{I, T} that maps a simplex index to its birth time. The first element of this Vector corresponds to vertices, second to 1-simplices etc.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.adjacency_matrix(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/extensions/#LightGraphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}","page":"Interfaces","title":"LightGraphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(::AbstractFiltration)\n\nReturn the adjacency matrix. For sparse filtrations, this should return a SparseMatrixCSC.\n\nExamples\n\njulia> Ripserer.adjacency_matrix(Rips([0 2 1; 2 0 1; 1 1 0]))\n3×3 Array{Int64,2}:\n 0  2  1\n 2  0  1\n 1  1  0\n\njulia> Ripserer.adjacency_matrix(Rips([0 10 2; 10 0 1; 2 1 0]; sparse=true))\n3×3 SparseArrays.SparseMatrixCSC{Int64,Int64} with 4 stored entries:\n  [3, 1]  =  2\n  [3, 2]  =  1\n  [1, 3]  =  2\n  [2, 3]  =  1\n\njulia> Ripserer.adjacency_matrix(Custom([(2, 1) => 1, (5, 1) => 2, (3, 4) => 3]))\n5×5 SparseArrays.SparseMatrixCSC{Bool,Int64} with 6 stored entries:\n  [2, 1]  =  1\n  [5, 1]  =  1\n  [1, 2]  =  1\n  [4, 3]  =  1\n  [3, 4]  =  1\n  [1, 5]  =  1\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/#Simplex-Interface","page":"Interfaces","title":"Simplex Interface","text":"","category":"section"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.AbstractSimplex","category":"page"},{"location":"api/extensions/#Ripserer.AbstractSimplex","page":"Interfaces","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, T, I} <: AbstractVector{I}\n\nAn abstract type for representing simplices. A simplex must have a diameter of type T, which is its birth time. The dimension must be encoded in the type as D and can be accessed by dim.\n\nThe simplex is expected to act like an array of indices of type I, but this is not actually needed for the main algorithm.\n\nInterface\n\nAbstractSimplex{D}(::SVector{<:Any, <:Integer}, ::T)\nbirth(::AbstractSimplex)\nindex(::AbstractSimplex)\nsign(::AbstractSimplex)\ncoboundary(::Any, ::AbstractSimplex)\nboundary(::Any, ::AbstractSimplex)\nvertices(::AbstractSimplex)\nBase.:-(::AbstractSimplex)\n\n\n\n\n\n","category":"type"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"index(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/extensions/#Ripserer.index-Tuple{Ripserer.AbstractSimplex}","page":"Interfaces","title":"Ripserer.index","text":"index(simplex::AbstractSimplex)\n\nGet the combinatorial index of the simplex. The index can be any type, but should uniquely identify a simplex. It is also used to break ties when comparing simplices with the same birth time.\n\njulia> index(Simplex{2}((3, 2, 1), 3.2))\n1\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Base.sign(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/extensions/#Base.sign-Tuple{Ripserer.AbstractSimplex}","page":"Interfaces","title":"Base.sign","text":"sign(simplex::AbstractSimplex)\n\nGet the orientation of simplex. Should return -1 or 1.\n\nExamples\n\njulia> sign(Simplex{2}((3, 2, 1), 3.2))\n1\n\njulia> sign(-Simplex{2}((3, 2, 1), 3.2))\n-1\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Base.:-(::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/extensions/#Base.:--Tuple{Ripserer.AbstractSimplex}","page":"Interfaces","title":"Base.:-","text":"-(simplex::AbstractSimplex)\n\nReverse the simplex orientation.\n\nExample\n\njulia> -Simplex{2}((3, 2, 1), 3.2)\n2-dimensional Simplex(index=1, birth=3.2):\n  -[3, 2, 1]\n\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.coboundary(::Any, ::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/extensions/#Ripserer.coboundary-Tuple{Any,Ripserer.AbstractSimplex}","page":"Interfaces","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the coboundary of simplex by decreasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nIf all_cofacets is false, only return cofaces with vertices added to the beginning of vertex list. The method with all_cofacets only has to be implemented if the filtration does not overload columns_to_reduce.\n\nComes with a default implementation.\n\nwarning: Warning\nIf cofacets are not returned in decreasing index order, the algorithm will not work correctly. If there is no avoiding it, define emergent_pairs(...) = false for your filtration.\n\nExamples\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor c in Ripserer.coboundary(filtration, Simplex{1}(2, 1))\n    println(c)\nend\n\n# output\n\n+Simplex{2}([4, 3, 1], 1)\n-Simplex{2}([3, 2, 1], 1)\n\nfor c in Ripserer.coboundary(filtration, Simplex{1}(2, 1), Val(false))\n    println(c)\nend\n\n# output\n\n+Simplex{2}([4, 3, 1], 1)\n\n\n\n\n\n","category":"method"},{"location":"api/extensions/","page":"Interfaces","title":"Interfaces","text":"Ripserer.boundary(::Any, ::Ripserer.AbstractSimplex)","category":"page"},{"location":"api/extensions/#Ripserer.boundary-Tuple{Any,Ripserer.AbstractSimplex}","page":"Interfaces","title":"Ripserer.boundary","text":"boundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the boundary of simplex by increasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nComes with a default implementation.\n\nwarning: Warning\nIf facets are not returned in increasing index order, the (homology) algorithm will not work correctly. If there is no avoiding it, define emergent_pairs(...) = false for your filtration.\n\nExample\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor f in Ripserer.boundary(filtration, Simplex{2}(2, 1))\n    println(f)\nend\n\n# output\n\n+Simplex{1}([2, 1], 1)\n-Simplex{1}([4, 1], 1)\n+Simplex{1}([4, 2], 1)\n\n\n\n\n\n","category":"method"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/stability.jl\"","category":"page"},{"location":"generated/stability/#Stability","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"In this example, we will demonstrate the stability of persistent homology. The stability theorem roughly states that a small change in the input data will result in a small change in the resulting persistence diagram. In other words, persistent homology is very tolerant of noisy data. Also, see the Distances example in PersistenceDiagrams.jl.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, start with loading some packages.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"As in the Basics example, we will look at the persistent homology of a noisy circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"function noisy_circle(n; r1=1, r2=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r1*sin(θ) + noise*rand() - noise/2,\n                       r2*cos(θ) + noise*rand() - noise/2))\n    end\n    points\nend","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We will look at the first persistent homology group of this space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"First, let's see what happens if we repeatedly sample 100 random points from a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_1.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We notice that an interval in H_1 always stands out and that its death remains constant. The only thing that changes is the birth time. The birth time is equal to the largest distance between adjacent points in the circle. At the birth time, the circle is connected.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Now, let's add some noise!","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0.2)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_2.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"The interval is jumping around a lot more now, but it hovers around the same general area. It's still clearly the most persistent feature of our space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Next, let's look at how adding more and more noise affects the diagram.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for noise in vcat(0:0.01:1, 1:-0.01:0)\n    points = noisy_circle(100, noise=noise)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_3.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We see we have to add quite a bit of noise to destroy the diagram. Notice how the death time of the interval decreases as we add noise. This is the result of the diameter of the hole in our circle shrinking.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Finally, let's stretch our circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for r in vcat(0.0:0.02:2, 2:-0.02:0.0)\n    points = noisy_circle(100, noise=0.1, r1=r)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_4.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, we see the persistent homology stays stable, as long as the data at least somewhat resembles a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Ripserer.jl","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible and efficient persistent homology computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Matija Čufar (@mtsch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is a pure Julia library for computing persistent homology based on the Ripser algorithm. Roughly speaking, persistent homology detects the global topological and local geometric structure of data in a noise-resistant, stable way. If you are unfamiliar with persistent homology, I recommend reading this excellent introduction. See the Examples for further info and usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main goal of this project is to provide an easy to use, generic and fast implementation of persistent homology to the Julia ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While this package is fully functional, it is still in development and should not be considered stable. I try to disrupt the public interface as little as possible, but breaking changes might still occur from time to time.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered. To install it, simply run the following and everything should just work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(\"Ripserer\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"All versions of Julia from 1.0 onward are supported, but I recommend using the latest version of Julia for optimal performance.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer and its companion package PersistenceDiagrams.jl currently support","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast Vietoris-Rips and cubical persistent homology computation.\nRepresentative cocycle and critical simplex computation.\nConvenient persistence diagram and representative cocycle visualization via Plots.jl. Experimental Makie.jl support is also available.\nBottleneck and Wasserstein matching and distance computation.\nVarious persistence diagram vectorization functions, implemented with persistence images and persistence curves.\nEasy extensibility through a documented API.\nComputing persistent homology and representative cycles (experimental).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access some of the features, you need to use PersistenceDiagrams.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much like Ripser, Ripserer uses implicit simplicial complex and reduction matrix representations combined with the clearing optimization and other computational tricks to achieve its speed. For a more detailed overview of these optimizations, check out Ulrich Bauer's article on Ripser.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to Ripser, usually within around 30%. Cubical homology is up to 3× slower than that of Cubical Ripser, which uses a more specialized algorithm. Ripserer is still a good choice for small 3d images and large 2d images. Ripserer's strength performance-wise is very sparse inputs. It also computes some things Ripser skips, like the critical simplices. See the Benchmarks section for detailed benchmarks.","category":"page"},{"location":"#Extensibility","page":"Home","title":"Extensibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. See the Filtration Interface and Simplex Interface API sections for more info. To see an example of an extension, check out the implementation of cubical homology in src/cubical.jl. Keep in mind that this extension customizes almost every aspect of the algorithm and that extensions can usually be much simpler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have written an extension or are having trouble implementing one, please feel free to open a pull request or an issue, or contact me directly.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All contributions are welcome, even small things like typo fixes and ideas! See the contribution guidelines for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you used this software in a cool project, or if you have any comments, questions, or suggestions, feel free to contact me at matijacufar@gmail.com.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/basics.jl\"","category":"page"},{"location":"generated/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In this example, we will present the usage of Ripserer. We start by loading some packages.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/basics/#Basic-Usage","page":"Basics","title":"Basic Usage","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Let's start with a basic example, points randomly sampled from a noisy circle. We start by defining our sampling function.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"function noisy_circle(n; r=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r*sin(θ) + noise*rand(), r*cos(θ) + noise*rand()))\n    end\n    points\nend","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Next, we sample 100 points from the circle.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"circ_100 = noisy_circle(100)\nscatter(circ_100, aspect_ratio=1, legend=false, title=\"Noisy Circle\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply run the following. The dim_max argument sets the maximum dimension persistent homology is computed in.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_circ = ripserer(circ_100, dim_max=3)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"warning: Warning\nComputing Vietoris-Rips persistent homology in high dimensions for large numbers of points is computationally expensive and requires a large amount of memory. Be careful or you will run out of memory. On an ordinary computer, you can expect to compute one-dimensional persistent homology for datasets of a few thousand points and higher (2-3) dimensional persistent homology for datasets of a few hundred points. This, of course, depends on the data set itself.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"The result can be plotted as a persistence diagram.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_circ)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Or as a barcode.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"H_1, H_2, and H_3 in this plot are hard to see because we have too many H_0 bars. We can plot only some of the diagrams.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"note: Note\nresult is just an array of persistence diagrams, so the zero-dimensional diagram is found at index 1.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ[2:end], linewidth=2)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We can plot a single diagram in the same manner.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"barcode(result_circ[3], linewidth=3)","category":"page"},{"location":"generated/basics/#Distance-Matrix-Inputs","page":"Basics","title":"Distance Matrix Inputs","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In the previous example, we got our result by passing a collection of points to ripserer.  Under the hood, the algorithm actually works with distance matrices. Let's define a distance matrix of the shortest paths on a regular icosahedron graph.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Icosahedron_graph.svg\" height=\"250\" width=\"250\">","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"icosahedron = [0 1 2 2 1 2 1 1 2 2 1 3;\n               1 0 3 2 1 1 2 1 2 1 2 2;\n               2 3 0 1 2 2 1 2 1 2 1 1;\n               2 2 1 0 3 2 1 1 2 1 2 1;\n               1 1 2 3 0 1 2 2 1 2 1 2;\n               2 1 2 2 1 0 3 2 1 1 2 1;\n               1 2 1 1 2 3 0 1 2 2 1 2;\n               1 1 2 1 2 2 1 0 3 1 2 2;\n               2 2 1 2 1 1 2 3 0 2 1 1;\n               2 1 2 1 2 1 2 1 2 0 3 1;\n               1 2 1 2 1 2 1 2 1 3 0 2;\n               3 2 1 1 2 1 2 2 1 1 2 0]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply feed the distance matrix to ripserer.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_icosa = ripserer(icosahedron, dim_max=2)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Because an icosahedron is topologically equivalent to a sphere, we got a single class in the second dimension.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_icosa[3]","category":"page"},{"location":"generated/basics/#Thresholding","page":"Basics","title":"Thresholding","text":"","category":"section"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"In our next example, we will show how to use thresholding to speed up computation. We start by defining a sampling function that generates n points from the square -44times-44 with a circular hole of radius 1 in the middle.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"function cutout(n)\n    points = NTuple{2, Float64}[]\n    while length(points) < n\n        x, y = (8rand() - 4, 8rand() - 4)\n        if x^2 + y^2 > 1\n            push!(points, (x, y))\n        end\n    end\n    points\nend","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We sample 2000 points from this space.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"cutout_2000 = cutout(2000)\nscatter(cutout_2000, markersize=1, aspect_ratio=1, legend=false, title=\"Cutout\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"We calculate the persistent homology and time the calculation.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut = ripserer(cutout_2000)\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut)","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Notice that while there are many 1-dimensional classes, one of them stands out. This class represents the hole in the middle of our square. We can extract this interval by doing the following.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"most_persistent = sort(result_cut[2], by=persistence)[end]","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Notice the death time of this interval is around 1.83 and that no intervals occur after that time. This means that we could stop computing when we reach this time and the result should not change. Let's try it out!","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut_thresh_2 = ripserer(cutout_2000, threshold=2)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_2, title=\"Persistence Diagram, threshold=2\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"Indeed, the result is exactly the same, but it took less than a third of the time to compute.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"result_cut_thresh_2 == result_cut","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"If we pick a threshold that is too low, we still detect the interval, but its death time becomes infinite.","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"@time result_cut_thresh_1 = ripserer(cutout_2000, threshold=1)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_1, title=\"Persistence Diagram, threshold=1\")","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"generated/basics/","page":"Basics","title":"Basics","text":"This page was generated using Literate.jl.","category":"page"}]
}
