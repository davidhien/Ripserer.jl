var documenterSearchIndex = {"docs":
[{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cocycles.jl\"","category":"page"},{"location":"generated/cocycles/#Representative-Cocycles-1","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"section"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"In this example, we will demonstrate how to compute and visualize representative cocycles of persistent homology generators.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"As always, we start by importing the relevant packages.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"using Ripserer\nusing Plots\ngr(); nothing # hide","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"We define a function that generates some data sampled from a curve.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"function curve(n)\n    [(sin(t)+t/10, cos(t)+t/10) for t in range(0, 2π, length=n)]\nend\n\nplot(curve(100), legend=false, title=\"Curve\", aspect_ratio=1, xlab=\"x\", ylab=\"y\")","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"Then, we compute the persistent homology of that data with various numbers of points. We plot the representative cocycles of each result and turn them into an animation. This data set will always have at most one one-dimensional class. We invoke plot(interval, data) to plot the representative cocycle of the class. The same plot could be created by invoking representative(interval).","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"anim = @animate for i in vcat(3:100, 100:-1:3)\n    points = curve(i)\n    res = ripserer(points, representatives=true)\n\n    plt1 = plot(title=\"1-dimensional Representative Cocycle\",\n                xlab=\"x\",\n                ylab=\"y\",\n                legend=false,\n                ylim=(-0.8, 1.8),\n                aspect_ratio=1)\n    if length(res[2]) > 0\n        interval = res[2][1]\n        plot!(plt1, interval, points,\n              alpha=0.2,\n              linewidth=2,\n              color=3)\n    end\n    scatter!(plt1, points, color=2)\n    plot(plt1, barcode(res), plot(res),\n         layout=@layout([a [b; c]]),\n         size=(800, 600))\nend\nmp4(anim, \"cocycles_anim.mp4\") # hide","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"We can save the animation by running the following.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"mp4(anim, \"cocycles_anim.mp4\")","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Ripserer-1","page":"API","title":"Ripserer","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"ripserer","category":"page"},{"location":"api/#Ripserer.ripserer","page":"API","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix{T}; kwargs...)\nripserer(points; metric=Euclidean(), births, kwargs...)\n\nCompute the persistent homology of metric space represented by dists or points and metric. points must be an array of bitstypes, such as NTuples or SVectors.\n\nKeyoword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nthreshold: compute persistent homology up to diameter smaller than threshold. For non-sparse Rips filtrations, it defaults to radius of input space.\nsparse: if true, use SparseRipsFiltration. Defaults to false. If the dists argument is a sparse matrix, it overrides this option.\nratio: only keep intervals with death(interval) > birth(interval) * ratio. Defaults to 1.\nrepresentatives: if true, return representative cocycles along with persistence intervals. Defaults to false.\nmetric: when calculating persistent homology from points, any metric from Distances.jl can be used. Defaults to Euclidean().\nbirths: when calculating persistent homology from points, births can be used to add birth times to vertices. Defaults to all births equal to 0.\n\n\n\n\n\nripserer(filtration::AbstractFiltration; dim_max=1)\n\nCompute persistent homology from filtration object.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"RipsFiltration","category":"page"},{"location":"api/#Ripserer.RipsFiltration","page":"API","title":"Ripserer.RipsFiltration","text":"RipsFiltration{T, V<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, V}\n\nThis type represents a filtration of Vietoris-Rips complexes. Diagonal items are treated as vertex birth times.\n\nConstructor\n\nRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=default_rips_threshold(dist),\n    vertex_type=Simplex{0, modulus, T, Int, UInt}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"SparseRipsFiltration","category":"page"},{"location":"api/#Ripserer.SparseRipsFiltration","page":"API","title":"Ripserer.SparseRipsFiltration","text":"SparseRipsFiltration{T, V<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, V}\n\nThis type represents a filtration of Vietoris-Rips complexes. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as ∞. Diagonal items are treated as vertex birth times.\n\nConstructor\n\nSparseRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=nothing,\n    vertex_type=Simplex{modulus, T}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Persistence-Intervals-and-Diagrams-1","page":"API","title":"Persistence Intervals and Diagrams","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"PersistenceInterval","category":"page"},{"location":"api/#Ripserer.PersistenceInterval","page":"API","title":"Ripserer.PersistenceInterval","text":"PersistenceInterval{T, C}\n\nThe type that represents a persistence interval. It behaves exactly like a Tuple{T, Union{T, Infinity}}, but may have a representative cocycle attached to it.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"birth(::PersistenceInterval)","category":"page"},{"location":"api/#Ripserer.birth-Tuple{PersistenceInterval}","page":"API","title":"Ripserer.birth","text":"birth(interval::PersistenceInterval)\n\nGet the birth time of interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"death(::PersistenceInterval)","category":"page"},{"location":"api/#Ripserer.death-Tuple{PersistenceInterval}","page":"API","title":"Ripserer.death","text":"death(interval::PersistenceInterval)\n\nGet the death time of interval. When T<:AbstractFloat, Inf is returned instead of ∞.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"persistence(::PersistenceInterval)","category":"page"},{"location":"api/#Ripserer.persistence-Tuple{PersistenceInterval}","page":"API","title":"Ripserer.persistence","text":"death(interval::PersistenceInterval)\n\nGet the persistence of interval, which is equal to death - birth. When T<:AbstractFloat, Inf is returned instead of ∞.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"representative(::PersistenceInterval)","category":"page"},{"location":"api/#Ripserer.representative-Tuple{PersistenceInterval}","page":"API","title":"Ripserer.representative","text":"representative(interval::PersistenceInterval)\n\nGet the representative cocycle attached to interval. If representatives were not computed, throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"PersistenceDiagram","category":"page"},{"location":"api/#Ripserer.PersistenceDiagram","page":"API","title":"Ripserer.PersistenceDiagram","text":"PersistenceDiagram{P<:PersistenceInterval} <: AbstractVector{P}\n\nType for representing persistence diagrams. Behaves exactly like an array of PersistenceIntervals, but is aware of its dimension and supports pretty printing and plotting.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"barcode(::Union{PersistenceDiagram, AbstractVector{<:PersistenceDiagram}})","category":"page"},{"location":"api/#Ripserer.barcode-Tuple{Union{AbstractArray{#s12,1} where #s12<:PersistenceDiagram, PersistenceDiagram}}","page":"API","title":"Ripserer.barcode","text":"barcode(diagram; infinity=nothing)\n\nPlot the barcode plot or AbstractVector of diagrams. The infinity keyword argument determines where the infinity line is placed. If set to nothing the function tries to guess a good infinity poistion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simplex-Types-1","page":"API","title":"Simplex Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractSimplex","category":"page"},{"location":"api/#Ripserer.AbstractSimplex","page":"API","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, C, T}\n\nAn abstract type for representing simplices. A simplex is represented by its dimension, diameter, combinatorial index and coefficient value. It does not need to hold information about its the vertices it includes, since they can be recomputed from the index and dimension.\n\nD is the dimension, T is the type of distance and C is the coefficient type. D is accessible by dim(::AbstractSimplex).\n\nInterface\n\nindex(::AbstractSimplex)\ncoef(::AbstractSimplex)\nset_coef(::AbstractSimplex, ::Any)\ndiam(::AbstractSimplex)\ncoface_type(::AbstractSimplex)\nvertices(::AbstractSimplex) - optional, comes with a default implementation.\ncoboundary(filtration, ::AbstractSimplex) - optional, comes with a default implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"index(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.index-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.index","text":"index(simplex::AbstractSimplex)\n\nGet the combinatorial index of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coef(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.coef-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.coef","text":"coef(simplex::AbstractSimplex)\n\nGet the coefficient value of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"set_coef(::AbstractSimplex, ::Any)","category":"page"},{"location":"api/#Ripserer.set_coef-Tuple{AbstractSimplex,Any}","page":"API","title":"Ripserer.set_coef","text":"set_coef(simplex::AbstractSimplex, value)\n\nReturn new simplex of the same type with new coefficient value.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.diam","text":"diam(simplex::AbstractSimplex)\n\nGet the diameter of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"dim(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.dim-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.dim","text":"dim(::AbstractSimplex)\ndim(::Type{<:AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"vertices(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.vertices-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.vertices","text":"vertices(index, ::Val{dim})\n\nGet the vertices of simplex represented by index. Returns NTuple{dim+1, Int}.\n\n\n\n\n\nvertices(sx::AbstractSimplex{dim})\n\nGet the vertices of simplex sx. Returns NTuple{dim+1, Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coface_type(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.coface_type-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.coface_type","text":"coface_type(::AbstractSimplex)\ncoface_type(::Type{<:AbstractSimplex})\n\nGet the type of coface a simplex hax. For a D-dimensional simplex, this is usually its D+1-dimensional counterpart. Only the coface_type(::Type{<:AbstractSimplex}) method needs to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coboundary","category":"page"},{"location":"api/#Ripserer.coboundary","page":"API","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex)\n\nFind the coboundary of simplex. Use the filtration to determine the diameters and validity of cofaces. Iterates values of the type coface_type(simplex).\n\n\n\n\n\n","category":"function"},{"location":"api/#Filtration-Types-1","page":"API","title":"Filtration Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFiltration","page":"API","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{T, V<:AbstractSimplex{0, C, T}}\n\nA filtration is used to find the edges in filtration and to determine diameters of simplices.\n\nT is the distance type, accessible by dist_type and S is the edge type, accesible by edge_type.\n\nInterface\n\nn_vertices(::AbstractFiltration)\nedges(::AbstractFiltration)\ndiam(::AbstractFiltration, vs)\ndiam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any)\nSparseArrays.issparse(::Type{A}) where A<:AbstractFiltration - optional, defaults to false.\nbirth(::AbstractFiltration, v) - optional, defaults to returning zero(T).\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"AbstractFlagFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFlagFiltration","page":"API","title":"Ripserer.AbstractFlagFiltration","text":"AbstractFlagFiltration{T, V} <: AbstractFiltration{T, V}\n\nAn abstract flag filtration is a filtration of flag complexes. Its subtypes can overload dist(::AbstractFlagFiltration{T}, u, v)::Union{T, Infinity} instead of diam. diam(::AbstractFlagFiltration, ...) defaults to maximum dist among vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"n_vertices(::AbstractFiltration)","category":"page"},{"location":"api/#Ripserer.n_vertices-Tuple{AbstractFiltration}","page":"API","title":"Ripserer.n_vertices","text":"n_vertices(filtration::AbstractFiltration)\n\nReturn the number of vertices in filtration.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"edges(::AbstractFiltration)","category":"page"},{"location":"api/#Ripserer.edges-Tuple{AbstractFiltration}","page":"API","title":"Ripserer.edges","text":"edges(filtration::AbstractFiltration)\n\nGet edges in distance matrix in filtration, sorted by decresing length and increasing combinatorial index. Edges should be of type edge_type(filtration).\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::Any)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractFiltration,Any}","page":"API","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, vertices)\n\nGet the diameter of list of vertices i.e. diameter of simplex with vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractFiltration,AbstractSimplex,Any,Any}","page":"API","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, simplex, vertices, vertex)\n\nGet the diameter of coface of simplex that is formed by adding vertex to vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"issparse(::AbstractFiltration)","category":"page"},{"location":"api/#SparseArrays.issparse-Tuple{AbstractFiltration}","page":"API","title":"SparseArrays.issparse","text":"SparseArrays.issparse(::Type{<:AbstractFiltration})\n\nReturn true if A is a sparse filtration. A filtration should be sparse if most simplices are to be skipped. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/time_series_sublevel.jl\"","category":"page"},{"location":"generated/time_series_sublevel/#Sublevel-Time-Series-Filtrations-1","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"","category":"section"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"This example is based on an example from ripser.py.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"In this example, we will show how we can use the 0-dimensional persistent homology to find local minia or maxima of time series data in a noise-resistant way.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We start by loading the required packages.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"using Ripserer\nusing Plots\nusing SparseArrays\n\nusing Random; gr(); Random.seed!(1337); nothing # hide","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Let's generate some data. We sample 1000 points from a noisy cosine on a slope.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"n = 1000\nx = range(0, 5, length=n)\ny = rand(n) .+ cos.(2π * x) .+ x\nplot(x, y, xlab=\"x\", ylab=\"y\", legend=false, title=\"Data\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Even though this time series is noisy, we would like to locate the five local minima that can clearly be seen from the plot.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We construct a distance matrix for the sublevel filtration. In this matrix, there is a vertex for each point in our series. We add vertex births, which are equal to the y values to the diagonal. Adjacient vertices are connected with edges, each having a weight equal to the maximum of its endpoints' births. If we were looking for local maxima, we would use the min function instead.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"dist = spzeros(n, n)\nfor i in 1:n\n    dist[i, i] = y[i]\nend\nfor i in 1:n-1\n    j = i+1\n    dist[i, j] = dist[j, i] = max(dist[i, i], dist[j, j])\nend","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Next, we compute 0-dimensional persistent homology. The resulting persistence diagram contains an interval for each local minimum. The interval's birth time is equal to the y-value at the minimum. It's death time is equal to the height of an adjacient local maximum. An interval with infinite persistence represents the global minimum.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"res = ripserer(dist, dim_max=0, representatives=true)[1]\nplot(res)","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We notice there is a lot of noise on the persistence diagram. We can filter it out by only keeping the intervals with persistence larger than 1.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"res = filter(x -> persistence(x) > 1, res)\nplot(res)","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"After filtering we are left with the five intervals corresponding to the local minima we are interested in.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We separate the infinite interval from the finite ones.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"infinite = only(filter(!isfinite, res))\nfinite = filter(isfinite, res)\nnothing # hide","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We set up a plot showing the representative of the infinite interval, which is equal to the whole time series. Then, we overlay a series for each of the other intervals.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"plt = plot(infinite, x, y,\n           seriestype=:path,\n           label=string(infinite),\n           legend=:bottomright,\n           xlab=\"x\", ylab=\"y\",\n           title=\"Persistent Local Minima\")\nfor int in finite\n    plot!(plt, int, x, y,\n          seriestype=:path,\n          label=string(int))\nend","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Then, we add a series showin the local minima. As mentioned before, the values of the minima correspond to the birth times of intervals. We find the indices of the minima by finding the simplices with the lowest diameter in the lists of representative cocycles. Indexing into x with those will give us x-positions of the minima.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"x_mins = x[index.(first(sort(rep, by=diam)) for rep in representative.(res))]\ny_mins = birth.(res)\nscatter!(x_mins, y_mins, color=1:5, markershape=:star, label=\"minima\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"And finally, we plot a close-up of one of the minima to ensure we got the correct answer.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"plot(res[4], x, y,\n     color=4,\n     seriestype=:path,\n     markershape=:d,\n     markersize=2,\n     xlab=\"x\", ylab=\"y\",\n     label=string(res[4]),\n     title=\"Closeup of the 4th Local Minimum\")\nscatter!([x_mins[4]], [y_mins[4]], color=4, markershape=:star, label=\"minimum\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Plots; gr()","category":"page"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This package is still under development and is currently unregistered. To install it, run the following.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(\"https://github.com/mtsch/Ripserer.jl\")","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Generate 100 points sampled from a torus.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"n = 10\nr = 1\nR = 4\ntorus = [((R + r*cos(θ))*cos(φ), (R + r*cos(θ))*sin(φ), r*sin(θ))\n         for θ in range(0, 2π, length=n+1)[1:end-1]\n         for φ in range(0, 2π, length=n+1)[1:end-1]]\nlength(torus)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Run Ripserer.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Ripserer\nresult = ripserer(torus)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Plot the result as a persistence diagram or barcode.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Plots; gr()\nplot(result)\nsavefig(\"diagram1.svg\"); nothing # hide\nbarcode(result)\nsavefig(\"barcode1.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"We notice some noise around the diagonal. This can be mitigated by running Ripserer with ripserer(torus, ratio=2) or by simply filtering the diagram.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"result[2] = filter(x -> death(x) > 2birth(x), result[2])\nplot(result)\nsavefig(\"diagram2.svg\"); nothing # hide\nbarcode(result)\nsavefig(\"barcode2.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"#Ripserer.jl-1","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient computation of persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is a pure Julia implementation of the Ripser algorithm for computing persistent homology. Roughly speaking, persistent homology detects topological holes in data in a noise-resistant, stable way. If you are unfamiliar with persistent homology, I recommend reading this excellent introduction.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Examples for further info.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer supports the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Fast computation of Vietoris-Rips persistent homology.\nCalculation of persistent homology with coefficients in the field of mathbbZ_p for a prime p.\nSparse distance matrix and thresholding support.\nComputing representative cocycles of persistent cohomology.\nSublevel set filtrations.\nPlotting persistence diagrams and barcodes.\nGeneric API.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is not yet a full TDA software framework, since some essential features, such as computing distances between persistence diagrams, are not available. Vietoris-Rips complexes are also not the right fit for all kinds of data.","category":"page"},{"location":"#Performance-1","page":"Home","title":"Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Much like Ripser, Ripserer uses the following optimizations to achieve its speed.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compute persistent cohomology.\nApply the clearing optimization.\nDon't store things that can be easily recomputed.\nSkip apparent and emergent persistence pairs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a detailed description of the algorithm, please see the original article.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to Ripser. Depending on the data set, one or the other may be faster and the differences are usually small. There are no official benchmarks, because I have found benchmarking on my computer or a CI system to be too unreliable.","category":"page"},{"location":"#Extending-1","page":"Home","title":"Extending","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. There are currently no extensions available, but implementing one should (in theory) be as simple as overloading a few functions. The interfaces are specified in the docstrings for AbstractSimplex and AbstractFiltration. Also see the API for more info.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you have written an extension or have trouble implementing one, please open a pull request or an issue.","category":"page"},{"location":"#Acknowledgments-1","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"I would like to thank:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@ubauer for creating the original Ripser on which this project is based.\n@ctralie and @sauln for creating ripser.py which has been a source of inspiration.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/basics.jl\"","category":"page"},{"location":"generated/basics/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In this example we will present the usage of Ripserer. We start by loading some packages.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/basics/#Basic-Usage-1","page":"Basics","title":"Basic Usage","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Let's start with a basic example, points randomly sampled from a noisy circle. We start by defining our sampling function.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"function noisy_circle(n; r=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r*sin(θ) + noise*rand(), r*cos(θ) + noise*rand()))\n    end\n    points\nend","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Next, we sample 100 points from the circle.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"circ_100 = noisy_circle(100)\nscatter(circ_100, aspect_ratio=1, legend=false, title=\"Noisy Circle\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply run the following. The dim_max argument sets the maximum dimension persistent homology is compted in.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_circ = ripserer(circ_100, dim_max=3)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"warning: Warning\nComputing persistent homology in high dimensions for large numbers of points is computationally expensive and requires a large amount of memory. Be careful or you will run out of memory. On an ordinary computer, you can expect to compute one-dimensional persistent homology for datasets of a few thousand points and higher (2-3) dimensional persistent homology for datasets of a few hundred points. This, of course, depends on the data set itself.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"The result can be plotted as a persistence diagram.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_circ)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Or as a barcode.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"H_1, H_2 and H_3 in this plot are hard to see, because we have too many H_0 bars. We can plot only some of the diagrams. Note that result is just an array of persistence diagrams, so the zero-dimensional diagram is found at index 1.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ[2:end], linewidth=2)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We can plot a single diagram in the same manner.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ[3], linewidth=3)","category":"page"},{"location":"generated/basics/#Distance-Matrix-Inputs-1","page":"Basics","title":"Distance Matrix Inputs","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In the previous example, we got our result by passing a collection of points to ripserer.  Under the hood, the algorithm actually works with distance matrices. Let's define a distance matrix of the shortest paths on a regular icosahedron graph.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Icosahedron_graph.svg\" height=\"250\" width=\"250\">","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"icosahedron = [0 1 2 2 1 2 1 1 2 2 1 3;\n               1 0 3 2 1 1 2 1 2 1 2 2;\n               2 3 0 1 2 2 1 2 1 2 1 1;\n               2 2 1 0 3 2 1 1 2 1 2 1;\n               1 1 2 3 0 1 2 2 1 2 1 2;\n               2 1 2 2 1 0 3 2 1 1 2 1;\n               1 2 1 1 2 3 0 1 2 2 1 2;\n               1 1 2 1 2 2 1 0 3 1 2 2;\n               2 2 1 2 1 1 2 3 0 2 1 1;\n               2 1 2 1 2 1 2 1 2 0 3 1;\n               1 2 1 2 1 2 1 2 1 3 0 2;\n               3 2 1 1 2 1 2 2 1 1 2 0]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply feed the distance matrix to ripserer.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_icosa = ripserer(icosahedron, dim_max=2)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Because an icosahedron is topologically equivalent to a sphere, we got a single class in the second dimension.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_icosa[3]","category":"page"},{"location":"generated/basics/#Thresholding-1","page":"Basics","title":"Thresholding","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In our next example, we will show how to use thresholding to speed up computation. We start by defining a sampling function that generates n points from the square -44times-44 with a circular hole of radius 1 in the middle.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"function cutout(n)\n    points = NTuple{2, Float64}[]\n    while length(points) < n\n        x, y = (8rand() - 4, 8rand() - 4)\n        if x^2 + y^2 > 1\n            push!(points, (x, y))\n        end\n    end\n    points\nend","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We sample 2000 points from this space.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"cutout_2000 = cutout(2000)\nscatter(cutout_2000, markersize=1, aspect_ratio=1, legend=false, title=\"Cutout\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We calculate the persistent homology and time the calculation.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"@time result_cut = ripserer(cutout_2000)\nnothing # hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_cut)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Notice that while there are many 1-dimensional classes, one of them stands out. This class represents the hole in the middle of our square. We can extract this interval by doing the following.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"most_persistent = sort(result_cut[2], by=persistence)[end]","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Notice the death time of this interval is around 1.83 and that no intervals occr after that time. This means that we could stop computing when we reach this time and the result should not change. Let's try it out!","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"@time result_cut_thr = ripserer(cutout_2000, threshold=1.83)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_cut_thr, title=\"Persistence Diagram, threshold=1.83\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Indeed, the result is exactly the same, but it took less than a third of the time to compute.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"If we pick a threshold that is too low, we still detect the interval, but its death time will become infinite. Let's demonstrate that with an animation.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"anim = @animate for threshold in 1.83:-0.03:0.09\n    result_cut_i = ripserer(cutout_2000, threshold=threshold)\n    pd_plt = plot(result_cut_i,\n                  infinity=threshold, # set the position of the infinity line\n                  xticks=0:0.1:1.9,\n                  yticks=0:0.1:1.9,\n                  title=\"threshold=$threshold\")\n    bc_plt = barcode(result_cut_i[2],\n                     infinity=threshold,\n                     xticks=0:0.1:1.9,\n                     ylim=(1, length(result_cut[2])))\n    plot(pd_plt, bc_plt,\n         size=(800, 400))\nend\nmp4(anim, \"basics_anim.mp4\") # hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/stability.jl\"","category":"page"},{"location":"generated/stability/#Stability-1","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"In this example we will demonstrate the stability of persistent homology. The stability theorem roughly states, that a small change in the input data will result in a small change in the resulting persistence diagram. In other words, persistent homology is very tolerant of noisy data.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Again, start with loading some packages.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"As in the Basics example, we will look at the persistent homology of a noisy circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"function noisy_circle(n; r1=1, r2=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r1*sin(θ) + noise*rand() - noise/2,\n                       r2*cos(θ) + noise*rand() - noise/2))\n    end\n    points\nend","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We will look at the first persistent homology group of this space.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"First, let's see what happens if we repeatedly sample 100 random points from a circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_1.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We notice that an interval in H_1 always stands out and that its death remains constant. The only thing that changes is the birth time. The birth time is equal to the largest distance between adjacient points in the circle. At birth time, the circle is connected.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Now, let's add some noise!","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0.2)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_2.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"The interval is jumping around a lot more now, but it hovers around the same general area. It's still clearly the most persistent feature of our space.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Next, let's look at how adding more and more noise affects the diagram.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for noise in vcat(0:0.01:1, 1:-0.01:0)\n    points = noisy_circle(100, noise=noise)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_3.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We see we have to add quite a bit of noise to destroy the diagram. Notice how the death time of the interval decreases as we add noise. This is the result of the diameter of the hole in our circle shrinking.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Finally, let's stretch our circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for r in vcat(0.0:0.02:2, 2:-0.02:0.0)\n    points = noisy_circle(100, noise=0.1, r1=r)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_4.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Again, we see the persistent homology stays stable, as long as the data at least somewhat resembles a circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"This page was generated using Literate.jl.","category":"page"}]
}
