var documenterSearchIndex = {"docs":
[{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cocycles.jl\"","category":"page"},{"location":"generated/cocycles/#Representative-Cocycles-1","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"section"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"In this example, we will demonstrate how to compute and visualize representative cocycles of persistent homology generators.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"As always, we start by importing the relevant packages.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"using Ripserer\nusing Plots\ngr(); nothing # hide","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"We define a function that generates some data sampled from a curve.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"function curve(n)\n    [(sin(t)+t/10, cos(t)+t/10) for t in range(0, 2π, length=n)]\nend\n\nplot(curve(100), legend=false, title=\"Curve\", aspect_ratio=1, xlab=\"x\", ylab=\"y\")","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"Then, we compute the persistent homology of that data with various numbers of points. We plot the representative cocycles of each result and turn them into an animation. This data set will always have at most one one-dimensional class. We invoke plot(interval, data) to plot the representative cocycle of the class. The same plot could be created by invoking representative(interval). We use the threshold_strict argument to only plot the simplices with diameter strictly lower than the death time of the interval.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"anim = @animate for i in vcat(3:100, 100:-1:3)\n    points = curve(i)\n    res = ripserer(points, reps=true)\n\n    plt1 = plot(title=\"1-dimensional Representative Cocycle\",\n                xlab=\"x\",\n                ylab=\"y\",\n                legend=false,\n                ylim=(-0.8, 1.8),\n                aspect_ratio=1)\n    if length(res[2]) > 0\n        interval = res[2][1]\n        plot!(plt1, interval, points,\n              alpha=0.2,\n              linewidth=2,\n              threshold_strict=death(interval),\n              color=3)\n    end\n    scatter!(plt1, points, color=2)\n    plot(plt1, barcode(res), plot(res),\n         layout=@layout([a [b; c]]),\n         size=(800, 600))\nend\nmp4(anim, \"cocycles_anim.mp4\") # hide","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"We can save the animation by running the following.","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"mp4(anim, \"cocycles_anim.mp4\")","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"","category":"page"},{"location":"generated/cocycles/#","page":"Representative Cocycles","title":"Representative Cocycles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/stability.jl\"","category":"page"},{"location":"generated/stability/#Stability-1","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"In this example we will demonstrate the stability of persistent homology. The stability theorem roughly states, that a small change in the input data will result in a small change in the resulting persistence diagram. In other words, persistent homology is very tolerant of noisy data. Also see the Distances example in PersistenceDiagrams.jl.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Again, start with loading some packages.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"As in the Basics example, we will look at the persistent homology of a noisy circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"function noisy_circle(n; r1=1, r2=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r1*sin(θ) + noise*rand() - noise/2,\n                       r2*cos(θ) + noise*rand() - noise/2))\n    end\n    points\nend","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We will look at the first persistent homology group of this space.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"First, let's see what happens if we repeatedly sample 100 random points from a circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_1.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We notice that an interval in H_1 always stands out and that its death remains constant. The only thing that changes is the birth time. The birth time is equal to the largest distance between adjacent points in the circle. At birth time, the circle is connected.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Now, let's add some noise!","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100, noise=0.2)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_2.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"The interval is jumping around a lot more now, but it hovers around the same general area. It's still clearly the most persistent feature of our space.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Next, let's look at how adding more and more noise affects the diagram.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for noise in vcat(0:0.01:1, 1:-0.01:0)\n    points = noisy_circle(100, noise=noise)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_3.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"We see we have to add quite a bit of noise to destroy the diagram. Notice how the death time of the interval decreases as we add noise. This is the result of the diameter of the hole in our circle shrinking.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Finally, let's stretch our circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"anim = @animate for r in vcat(0.0:0.02:2, 2:-0.02:0.0)\n    points = noisy_circle(100, noise=0.1, r1=r)\n    result = ripserer(points)\n\n    plt_pts = scatter(points, legend=false,\n                      aspect_ratio=1,\n                      xlim=(-2.2, 2.2),\n                      ylim=(-2.2, 2.2),\n                      title=\"Data\")\n    plt_diag = plot(result, infinity=3)\n\n    plot(plt_pts, plt_diag, size=(800, 400))\nend\ngif(anim, \"stability_anim_4.gif\") # hide","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"Again, we see the persistent homology stays stable, as long as the data at least somewhat resembles a circle.","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"","category":"page"},{"location":"generated/stability/#","page":"Stability","title":"Stability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/time_series_sublevel.jl\"","category":"page"},{"location":"generated/time_series_sublevel/#Sublevel-Time-Series-Filtrations-1","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"","category":"section"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"This example is based on an example from ripser.py.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"In this example, we will show how we can use the 0-dimensional persistent homology to find local minima or maxima of time series data in a noise-resistant way.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We start by loading the required packages.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"using Ripserer\nusing Plots\n\nusing Random; gr(); Random.seed!(1337); nothing # hide","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Let's generate some data. We sample 1000 points from a noisy cosine on a slope.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"n = 1000\nx = range(0, 5, length=n)\ny = rand(n) .+ cos.(2π * x) .+ x\nplot(x, y, xlab=\"x\", ylab=\"y\", legend=false, title=\"Data\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Even though this time series is noisy, we would like to locate the five local minima that can clearly be seen from the plot.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We do this by computing 0-dimensional persistent homology of the Cubical. The resulting persistence diagram contains an interval for each local minimum. The interval's birth time is equal to the y-value at the minimum. It's death time is equal to the height of an adjacent local maximum. An interval with infinite persistence represents the global minimum.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"res = ripserer(Cubical(y), dim_max=0, reps=true)[1]\nplot(res)","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We notice there is a lot of noise on the persistence diagram. We can filter it out by only keeping the intervals with persistence larger than 1.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"res = filter(x -> persistence(x) > 1, res)\nplot(res)","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"After filtering we are left with the five intervals corresponding to the local minima we are interested in.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We separate the infinite interval from the finite ones.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"infinite = only(filter(!isfinite, res))\nfinite = filter(isfinite, res)\nnothing # hide","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"We set up a plot showing the representative of the infinite interval, which is equal to the whole time series. Then, we overlay a series for each of the other intervals.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"plt = plot(infinite, x, y,\n           seriestype=:path,\n           label=string(infinite),\n           legend=:bottomright,\n           xlab=\"x\", ylab=\"y\",\n           title=\"Persistent Local Minima\")\nfor int in finite\n    plot!(plt, int, x, y,\n          seriestype=:path,\n          label=string(int))\nend","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"Then, we add a series showing the local minima. As mentioned before, the values of the minima correspond to the birth times of intervals. We find the indices of the minima by finding the simplices with the lowest diameter in the lists of representative cocycles. Indexing into x with those will give us x-positions of the minima.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"x_mins = x[first.(vertices.(first(sort(rep, by=diam)) for rep in representative.(res)))]\ny_mins = birth.(res)\nscatter!(plt, x_mins, y_mins, color=1:5, markershape=:star, label=\"minima\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"And finally, we plot a close-up of one of the minima to ensure we got the correct answer.","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"plot(res[4], x, y,\n     color=4,\n     seriestype=:path,\n     markershape=:d,\n     markersize=2,\n     xlab=\"x\", ylab=\"y\",\n     label=string(res[4]),\n     title=\"Closeup of the 4th Local Minimum\")\nscatter!([x_mins[4]], [y_mins[4]], color=4, markershape=:star, label=\"minimum\")","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"","category":"page"},{"location":"generated/time_series_sublevel/#","page":"Sublevel Time Series Filtrations","title":"Sublevel Time Series Filtrations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/image_sublevel.jl\"","category":"page"},{"location":"generated/image_sublevel/#Sublevel-Image-Filtrations-1","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"","category":"section"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"In this example, we will demonstrate sublevel persistent homology on images. We will use the Horizon telescope picture of a black hole. We will use the 768×768 pixel image. Computing the same result with a larger image should not be a problem, but the plots would make this page less responsive.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Start by loading the required packages and the image.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"using Ripserer\nusing Plots\nusing Images\ngr(); nothing # hide\nblackhole = load(joinpath(@__DIR__, \"../assets/blackhole768px.jpg\"))\n\nplot(blackhole, size=(800, 800))","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Convert the image to a matrix of floats.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"blackhole_grayscale = Float64.(Gray.(blackhole))","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"And plot it as a heatmap. Note that the image is flipped because matrices start at the top and images start at the bottom.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"heatmap(blackhole_grayscale, aspect_ratio=1, size=(800, 800))","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Compute the persistent homology.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"note: Note\nUnlike with Rips filtrations, we can use large data sets here because the number of simplices in a cubical filtration is linear to the size of the input. We still want to be careful with computing representatives because collecting them for thousands of persistence intervals can take a while.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"result_min = ripserer(Cubical(blackhole_grayscale))","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"We plot the diagram with the persistence argument. This plots persistence vs birth instead of death vs birth.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"plot(result_min, persistence=true)","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"We notice there is a lot of noise along the diagonal, but four intervals stand out. We remove the noise by supplying the cutoff argument to ripserer. This removes all intervals with persistence strictly smaller than cutoff.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"result_min = ripserer(Cubical(blackhole_grayscale), cutoff=0.1)","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"plot(result_min, persistence=true)","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Now that we know we have a smaller number of intervals, we can compute the representatives.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"result_min = ripserer(Cubical(blackhole_grayscale), cutoff=0.1, reps=true)","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"We separate the finite and infinite intervals. The finite one corresponds to the local minimum in the middle of the image and the infinite one corresponds to the global minimum.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"finite_interval = only(filter(isfinite, result_min[1]))\ninfinite_interval = only(filter(!isfinite, result_min[1]))\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Plot the location of the minima on the image. We have to use the threshold argument to only plot the simplices with diameter lower than or equal to the birth of the interval.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"heatmap(blackhole_grayscale, aspect_ratio=1, size=(800, 800))\nplot!(finite_interval, blackhole_grayscale,\n      color=2,\n      markershape=:d,\n      markerstrokecolor=2,\n      threshold=birth(finite_interval),\n      label=\"local minimum\")\n\nplot!(infinite_interval, blackhole_grayscale,\n      color=3,\n      markershape=:d,\n      markerstrokecolor=3,\n      threshold=birth(infinite_interval),\n      label=\"global minimum\")","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Note that there are several points for each minimum because several pixels have the same value.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"To plot the region of the local minimum, we skip the threshold and choose a small marker size. We will not plot the global minimum region because it encompasses the whole image.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"heatmap(blackhole_grayscale, aspect_ratio=1, size=(800, 800))\nplot!(finite_interval, blackhole_grayscale,\n      markersize=1,\n      color=1,\n      markerstrokecolor=1,\n      label=\"local minimum region\")","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"We can also plot the representatives of H_1, but keep in mind we have computed persistent cohomology. The representatives give us a chains that kill the first homology groups.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"heatmap(blackhole_grayscale, aspect_ratio=1, size=(800, 800))\nscatter!(result_min[2][1], blackhole_grayscale,\n         color=1,\n         label=\"H₁ killer1\",\n         markersize=0,\n         linewidth=4)\nscatter!(result_min[2][2], blackhole_grayscale,\n         color=3,\n         label=\"H₁ killer2\",\n         markersize=0,\n         linewidth=4)","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Note that the H_1 generators we found represent the regions around local maxima.  If we want to find the hole in the bright area, we must negate the image.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"Let's repeat what we just did, but with the image negated.","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"result_max = ripserer(Cubical(-blackhole_grayscale), cutoff=0.1, reps=true)\nplot(result_max)\n\nheatmap(blackhole_grayscale, aspect_ratio=1, size=(800, 800))\nscatter!(result_max[2][1], blackhole_grayscale,\n         color=1,\n         label=\"H₁ killer\",\n         markersize=0,\n         linewidth=4)\nplot!(result_max[1][1], blackhole_grayscale,\n      markershape=:d,\n      color=2,\n      markerstrokecolor=2,\n      threshold=birth(result_max[1][1]),\n      label=\"global maximum\")\nplot!(result_max[1][2], blackhole_grayscale,\n      markershape=:d,\n      color=3,\n      markerstrokecolor=3,\n      threshold=birth(result_max[1][2]),\n      label=\"local maximum\")","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"","category":"page"},{"location":"generated/image_sublevel/#","page":"Sublevel Image Filtrations","title":"Sublevel Image Filtrations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/ripserer/#Ripserer-1","page":"Ripserer","title":"Ripserer","text":"","category":"section"},{"location":"api/ripserer/#","page":"Ripserer","title":"Ripserer","text":"ripserer","category":"page"},{"location":"api/ripserer/#Ripserer.ripserer","page":"Ripserer","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix; kwargs...)\nripserer(points; metric=Euclidean(), births, kwargs...)\nripserer(filtration::AbstractFiltration; kwargs...)\n\nCompute the persistent homology of metric space represented by dists, points and metric or an ::AbstractFiltration.\n\nIf using points, points must be an array of bitstypes, such as NTuples or SVectors.\n\nKeyoword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nfield_type: use this type of field of coefficients. Defaults to Mod{modulus}.\nthreshold: compute persistent homology up to diameter smaller than threshold. For non-sparse Rips filtrations, it defaults to radius of input space.\ncutoff: only keep intervals with persistence(interval) > cutoff. Defaults to 0.\nreps: if true, return representative cocycles along with persistence intervals. Defaults to false.\nprogress: If true, show a progress bar. Defaults to false.\nmetric: when calculating persistent homology from points, any metric from Distances.jl can be used. Defaults to Euclidean().\nbirths: when calculating persistent homology from points, births can be used to add birth times to vertices. Defaults to all births equal to 0.\n\n\n\n\n\n","category":"function"},{"location":"api/ripserer/#","page":"Ripserer","title":"Ripserer","text":"Rips","category":"page"},{"location":"api/ripserer/#Ripserer.Rips","page":"Ripserer","title":"Ripserer.Rips","text":"Rips{I, T} <: AbstractFlagFiltration{T, Simplex}\n\nThis type represents a filtration of Vietoris-Rips complexes. Diagonal items are treated as vertex birth times.\n\nConstructor\n\nRips(\n    distance_matrix;\n    threshold=default_rips_threshold(dist),\n    vertex_type=Simplex{0, T, Int64},\n)\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/#","page":"Ripserer","title":"Ripserer","text":"SparseRips","category":"page"},{"location":"api/ripserer/#Ripserer.SparseRips","page":"Ripserer","title":"Ripserer.SparseRips","text":"SparseRips{I, T} <: AbstractFlagFiltration{T, Simplex}\n\nThis type represents a filtration of Vietoris-Rips complexes. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as missing. Diagonal items are treated as vertex birth times.\n\nConstructor\n\nSparseRips{I}(\n    distance_matrix;\n    threshold=nothing,\n)\n\n\n\n\n\n","category":"type"},{"location":"api/ripserer/#","page":"Ripserer","title":"Ripserer","text":"Cubical","category":"page"},{"location":"api/ripserer/#Ripserer.Cubical","page":"Ripserer","title":"Ripserer.Cubical","text":"Cubical{T, N} <: AbstractFiltration{T, <:Cubelet{0, T}}\n\nCubical is used to compute sublevel persistent homology on N-dimensional images, which are of type AbstractArray{T, N}.\n\nConstructor\n\nCubical(::AbstractArray{T, N})\n\n\n\n\n\n","category":"type"},{"location":"api/simplices/#Simplices-1","page":"Simplices","title":"Simplices","text":"","category":"section"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"AbstractSimplex","category":"page"},{"location":"api/simplices/#Ripserer.AbstractSimplex","page":"Simplices","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, T, I} <: AbstractVector{I}\n\nAn abstract type for representing simplices. A simplex must have a diameter of type T, which is its birth time. The dimension must be encoded in the type as D and can be accessed by dim.\n\nThe simplex is expected to act like an array of indices of type I, but this is not actually needed for the main algorithm.\n\nInterface\n\nAbstractSimplex{D}(::NTuple{D+1, <:Integer}, ::T)\ndiam(::AbstractSimplex)\nBase.sign(::AbstractSimplex)\nBase.:-(::AbstractSimplex)\nBase.isless(::AbstractSimplex, ::AbstractSimplex)\nvertices(::AbstractSimplex)\ncoface_type(::AbstractSimplex)\ncoboundary(::Any, ::AbstractSimplex)\nface_type(::AbstractSimplex) - only required for homology.\nboundary(::Any, ::AbstractSimplex) - only required for homology.\ncheck_overflow(::Type{<:AbstractSimplex}, ::Any) - optional.\n\n\n\n\n\n","category":"type"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"dim(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.dim-Tuple{AbstractSimplex}","page":"Simplices","title":"Ripserer.dim","text":"dim(::AbstractSimplex)\ndim(::Type{<:AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\ndim(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n2\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"diam(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.diam-Tuple{AbstractSimplex}","page":"Simplices","title":"Ripserer.diam","text":"diam(simplex::AbstractSimplex)\n\nGet the diameter of simplex.\n\ndiam(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n3.2\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"Base.sign(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Base.sign-Tuple{AbstractSimplex}","page":"Simplices","title":"Base.sign","text":"sign(simplex::AbstractSimplex)\n\nGet the orientation of simplex. Returns -1 or 1.\n\nsign(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n+1\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"Base.:-(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Base.:--Tuple{AbstractSimplex}","page":"Simplices","title":"Base.:-","text":"-(simplex::AbstractSimplex)\n\nReverse the simplex orientation.\n\n-Simplex{2}((3, 2, 1), 3.2)\n\n# output\n\n2-dim Simplex(1, 1):\n  -(3, 2, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"coface_type(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.coface_type-Tuple{AbstractSimplex}","page":"Simplices","title":"Ripserer.coface_type","text":"coface_type(::AbstractSimplex)\ncoface_type(::Type{<:AbstractSimplex})\n\nGet the type of simplex's coface. For a D-dimensional simplex, this is usually its D+1-dimensional counterpart. Only the method for the type needs to be implemented.\n\ncoface_type(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\nSimplex{3, Float64, Int}\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"vertices(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.vertices-Tuple{AbstractSimplex}","page":"Simplices","title":"Ripserer.vertices","text":"vertices(simplex::AbstractSimplex{dim})\n\nGet the vertices of simplex. Returns NTuple{dim+1, Int}. In the algorithm, only the method for 2-simplices is actually used.\n\nvertices(Simplex{2}((3, 2, 1), 3.2))\n\n# output\n\n(3, 2, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"coboundary(::Any, ::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.coboundary-Tuple{Any,AbstractSimplex}","page":"Simplices","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex[, Val{all_cofaces}])\n\nIterate over the coboundary of simplex. Use the filtration to determine the diameters and validity of cofaces. Iterates values of the type coface_type(simplex). If all_cofaces is false, only return cofaces with vertices added to the beginning of vertex list.\n\nfiltration = RipsFiltration([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor c in coboundary(filtration, Simplex{1}(2, 1))\n    println(c)\nend\n\n# output\n\nSimplex{2}(+(4, 3, 1), 1)\nSimplex{2}(-(3, 2, 1), 1)\n\nfor c in coboundary(filtration, Simplex{1}(2, 1), Val(false))\n    println(c)\nend\n\n# output\n\nSimplex{2}(+(4, 3, 1), 1)\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"IndexedSimplex","category":"page"},{"location":"api/simplices/#Ripserer.IndexedSimplex","page":"Simplices","title":"Ripserer.IndexedSimplex","text":"IndexedSimplex{D, T, I<:Integer} <: AbstractSimplex{D, T, I}\n\nA refinement of AbstractSimplex. An indexed simplex is represented by its dimension, diameter and combinatorial index of type I. It does not need to hold information about the vertices it includes, since they can be recomputed from the index and dimension.\n\nBy defining the index, a default implementation of sign, isless, vertices and coboundary is provided.\n\nInterface\n\nIndexedSimplex{D[, T, I]}(index::I, diam::T) - constructor.\nIndexedSimplex{D[, T, I]}(vertices::NTuple{D+1, I}, diam::T) - constructor.\ndiam(::AbstractSimplex)\ncoface_type(::AbstractSimplex)\nindex(::IndexedSimplex)\n\n\n\n\n\n","category":"type"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"index(::AbstractSimplex)","category":"page"},{"location":"api/simplices/#Ripserer.index-Tuple{AbstractSimplex}","page":"Simplices","title":"Ripserer.index","text":"index(vertices)\n\nCalculate the index from tuple of vertices. The index is equal to\n\n(i_d i_d-1  1) mapsto sum_k=1^d+1 binomi_k - 1k\n\nwhere i_k are the simplex vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"Simplex","category":"page"},{"location":"api/simplices/#Ripserer.Simplex","page":"Simplices","title":"Ripserer.Simplex","text":"Simplex{D, T, I} <: IndexedSimplex{D, T, I}\n\nThe vanilla simplex type represented by dimension D and index of type I and a diameter of type T.\n\nConstructor\n\nSimplex{D[, T, I]}(::I, ::T)\n\nExamples\n\nSimplex{2}(2, 1)\n\n# output\n\n2-dim Simplex{2}(2, 1):\n  +[4, 2, 1]\n\nSimplex{10}(Int128(-10), 1.0)\n\n# output\n\n4-dim Simplex{3}(1.0, 10, 2):\n  -Int128[12, 11, 10, 9, 8, 7, 6, 5, 4, 2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api/simplices/#","page":"Simplices","title":"Simplices","text":"Cubelet","category":"page"},{"location":"api/simplices/#Ripserer.Cubelet","page":"Simplices","title":"Ripserer.Cubelet","text":"Cubelet{D, T, I} <: IndexedSimplex{D, T, I}\n\nA Cubelet is similar to a Simplex, but it has 2^D vertices instead of D+1. Like in Simplex, the vertices are encoded from an index and dimension. Because a cubelet knows nothing about the image it came from, it returns linear indices from vertices.\n\nThe vertices should be neighboring indices, but this fact is not checked anywhere.\n\n\n\n\n\n","category":"type"},{"location":"#Ripserer.jl-1","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient computation of persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is a pure Julia library for computing persistent homology based on the Ripser algorithm. Roughly speaking, persistent homology detects topological holes in data in a noise-resistant, stable way. If you are unfamiliar with persistent homology, I recommend reading this excellent introduction.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Examples for further info.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Ripserer was created by Matija Čufar. If you used this software in your project, or if you have any comments, questions or suggestions, feel free to contact me at matijacufar@gmail.com.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"While this package is fully functional, it is still in development and should not be considered stable. Interfaces and internals may still change.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package is registered. To install it, simply run the following.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(\"Ripserer\")","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer supports the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Vietoris-Rips persistent homology.\nSublevel set persistent homology for multidimensional image and time series data.\nCalculation of persistent homology with coefficients in any (possibly user defined) field with the default of mathbbZ_p for a prime p.\nSparse distance matrix and thresholding support.\nComputing representative cocycles of persistent cohomology.\nPlotting persistence diagrams, barcodes, matchings and representative cocycles.\nGeneric API.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Ripserer uses PersistenceDiagrams.jl to represent persistence diagrams. It reexports some basic functionality, but please see that package for more persistence diagram-related functions.","category":"page"},{"location":"#Performance-1","page":"Home","title":"Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Much like Ripser, Ripserer uses the following optimizations to achieve its speed.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compute persistent cohomology.\nApply the clearing optimization.\nDon't store things that can be easily recomputed.\nSkip apparent and emergent persistence pairs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a detailed description of the algorithm, please see the Ulrich Bauer's article on Ripser.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to Ripser, within around 30%. Depending on the data set, one or the other may be faster. There are no official benchmarks, because I have found benchmarking on my computer or a CI system to be too unreliable.","category":"page"},{"location":"#Extending-1","page":"Home","title":"Extending","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. The interfaces are specified in the docstrings for AbstractSimplex and AbstractFiltration. Also see the Filtrations and Simplices API sections for more info. To see an example of an extension, check out the implementation of cubical simplices and filtrations in src/cubical.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you have written an extension or have trouble implementing one, please open a pull request or an issue.","category":"page"},{"location":"#Acknowledgments-1","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"I would like to thank:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@ubauer for creating the original Ripser on which this project is based.\n@ctralie and @sauln for creating ripser.py which has been a source of inspiration.\nŽiga Virk, for giving ideas and helping with the theoretical side of things.","category":"page"},{"location":"api/filtrations/#Filtrations-1","page":"Filtrations","title":"Filtrations","text":"","category":"section"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"AbstractFiltration","category":"page"},{"location":"api/filtrations/#Ripserer.AbstractFiltration","page":"Filtrations","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{T, S<:AbstractSimplex}\n\nA filtration is used to find the edges in filtration and to determine diameters of simplices.\n\nT is the distance type, accessible by dist_type and S is the edge type, accesible by vertex_type.\n\nInterface\n\nn_vertices(::AbstractFiltration)\nedges(::AbstractFiltration)\ndiam(::AbstractFiltration, vertices)\ndiam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any) - only used for Simplex.\nbirth(::AbstractFiltration, v) - optional, defaults to returning zero(T).\nthreshold(::AbstractFiltration) - optional, defaults to returning missing.\nsimplex_type(::AbstractFiltration, dim)\n\n\n\n\n\n","category":"type"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"n_vertices(::AbstractFiltration)","category":"page"},{"location":"api/filtrations/#Ripserer.n_vertices-Tuple{AbstractFiltration}","page":"Filtrations","title":"Ripserer.n_vertices","text":"n_vertices(filtration::AbstractFiltration)\n\nReturn the number of vertices in filtration.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"edges(::AbstractFiltration)","category":"page"},{"location":"api/filtrations/#Ripserer.edges-Tuple{AbstractFiltration}","page":"Filtrations","title":"Ripserer.edges","text":"edges(filtration::AbstractFiltration)\n\nGet edges in distance matrix in filtration, sorted by decresing length and increasing combinatorial index. Edges should be of type edge_type(filtration).\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"diam(::AbstractFiltration, ::Any)","category":"page"},{"location":"api/filtrations/#Ripserer.diam-Tuple{AbstractFiltration,Any}","page":"Filtrations","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, vertices)\n\nGet the diameter of list of vertices i.e. diameter of simplex with vertices. Retrun missing if vertices do not form a valid simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"diam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any)","category":"page"},{"location":"api/filtrations/#Ripserer.diam-Tuple{AbstractFiltration,AbstractSimplex,Any,Any}","page":"Filtrations","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, simplex, vertices, vertex)\n\nGet the diameter of coface of a Simplex that is formed by adding vertex to vertices. Return missing if new simplex is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"birth(::AbstractFiltration, ::Any)","category":"page"},{"location":"api/filtrations/#PersistenceDiagrams.birth-Tuple{AbstractFiltration,Any}","page":"Filtrations","title":"PersistenceDiagrams.birth","text":"birth(::AbstractFiltration, v)\n\nGet the birth time of vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"threshold(::AbstractFiltration)","category":"page"},{"location":"api/filtrations/#PersistenceDiagrams.threshold-Tuple{AbstractFiltration}","page":"Filtrations","title":"PersistenceDiagrams.threshold","text":"threshold(::AbstractFiltration)\n\nGet the threshold of filtration. This is the maximum diameter a simplex in the filtration can have. Used only for placing the infinity line in plotting.\n\n\n\n\n\n","category":"method"},{"location":"api/filtrations/#","page":"Filtrations","title":"Filtrations","text":"AbstractFlagFiltration","category":"page"},{"location":"api/filtrations/#Ripserer.AbstractFlagFiltration","page":"Filtrations","title":"Ripserer.AbstractFlagFiltration","text":"AbstractFlagFiltration{T, S} <: AbstractFiltration{T, S}\n\nAn abstract flag filtration is a filtration of flag complexes. Its subtypes can overload dist(::AbstractFlagFiltration{T}, u, v)::Union{T, Missing} instead of diam. diam(::AbstractFlagFiltration, ...) defaults to maximum dist among vertices.\n\n\n\n\n\n","category":"type"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/basics.jl\"","category":"page"},{"location":"generated/basics/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In this example we will present the usage of Ripserer. We start by loading some packages.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"using Ripserer\nusing Plots\nusing Random; Random.seed!(1337); gr(); nothing # hide","category":"page"},{"location":"generated/basics/#Basic-Usage-1","page":"Basics","title":"Basic Usage","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Let's start with a basic example, points randomly sampled from a noisy circle. We start by defining our sampling function.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"function noisy_circle(n; r=1, noise=0.1)\n    points = NTuple{2, Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r*sin(θ) + noise*rand(), r*cos(θ) + noise*rand()))\n    end\n    points\nend","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Next, we sample 100 points from the circle.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"circ_100 = noisy_circle(100)\nscatter(circ_100, aspect_ratio=1, legend=false, title=\"Noisy Circle\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply run the following. The dim_max argument sets the maximum dimension persistent homology is computed in.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_circ = ripserer(circ_100, dim_max=3)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"warning: Warning\nComputing Vietoris-Rips persistent homology in high dimensions for large numbers of points is computationally expensive and requires a large amount of memory. Be careful or you will run out of memory. On an ordinary computer, you can expect to compute one-dimensional persistent homology for datasets of a few thousand points and higher (2-3) dimensional persistent homology for datasets of a few hundred points. This, of course, depends on the data set itself.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"The result can be plotted as a persistence diagram.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_circ)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Or as a barcode.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"H_1, H_2 and H_3 in this plot are hard to see, because we have too many H_0 bars. We can plot only some of the diagrams.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"note: Note\nresult is just an array of persistence diagrams, so the zero-dimensional diagram is found at index 1.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ[2:end], linewidth=2)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We can plot a single diagram in the same manner.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"barcode(result_circ[3], linewidth=3)","category":"page"},{"location":"generated/basics/#Distance-Matrix-Inputs-1","page":"Basics","title":"Distance Matrix Inputs","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In the previous example, we got our result by passing a collection of points to ripserer.  Under the hood, the algorithm actually works with distance matrices. Let's define a distance matrix of the shortest paths on a regular icosahedron graph.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Icosahedron_graph.svg\" height=\"250\" width=\"250\">","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"icosahedron = [0 1 2 2 1 2 1 1 2 2 1 3;\n               1 0 3 2 1 1 2 1 2 1 2 2;\n               2 3 0 1 2 2 1 2 1 2 1 1;\n               2 2 1 0 3 2 1 1 2 1 2 1;\n               1 1 2 3 0 1 2 2 1 2 1 2;\n               2 1 2 2 1 0 3 2 1 1 2 1;\n               1 2 1 1 2 3 0 1 2 2 1 2;\n               1 1 2 1 2 2 1 0 3 1 2 2;\n               2 2 1 2 1 1 2 3 0 2 1 1;\n               2 1 2 1 2 1 2 1 2 0 3 1;\n               1 2 1 2 1 2 1 2 1 3 0 2;\n               3 2 1 1 2 1 2 2 1 1 2 0]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"To compute the persistent homology, simply feed the distance matrix to ripserer.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_icosa = ripserer(icosahedron, dim_max=2)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Because an icosahedron is topologically equivalent to a sphere, we got a single class in the second dimension.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_icosa[3]","category":"page"},{"location":"generated/basics/#Thresholding-1","page":"Basics","title":"Thresholding","text":"","category":"section"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"In our next example, we will show how to use thresholding to speed up computation. We start by defining a sampling function that generates n points from the square -44times-44 with a circular hole of radius 1 in the middle.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"function cutout(n)\n    points = NTuple{2, Float64}[]\n    while length(points) < n\n        x, y = (8rand() - 4, 8rand() - 4)\n        if x^2 + y^2 > 1\n            push!(points, (x, y))\n        end\n    end\n    points\nend","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We sample 2000 points from this space.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"cutout_2000 = cutout(2000)\nscatter(cutout_2000, markersize=1, aspect_ratio=1, legend=false, title=\"Cutout\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"We calculate the persistent homology and time the calculation.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"@time result_cut = ripserer(cutout_2000)\nnothing # hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_cut)","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Notice that while there are many 1-dimensional classes, one of them stands out. This class represents the hole in the middle of our square. We can extract this interval by doing the following.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"most_persistent = sort(result_cut[2], by=persistence)[end]","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Notice the death time of this interval is around 1.83 and that no intervals occur after that time. This means that we could stop computing when we reach this time and the result should not change. Let's try it out!","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"@time result_cut_thresh_2 = ripserer(cutout_2000, threshold=2)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_2, title=\"Persistence Diagram, threshold=2\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"Indeed, the result is exactly the same, but it took less than a third of the time to compute.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"result_cut_thresh_2 == result_cut","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"If we pick a threshold that is too low, we still detect the interval, but its death time becomes infinite.","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"@time result_cut_thresh_1 = ripserer(cutout_2000, threshold=1)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"plot(result_cut_thresh_1, title=\"Persistence Diagram, threshold=1\")","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"generated/basics/#","page":"Basics","title":"Basics","text":"This page was generated using Literate.jl.","category":"page"}]
}
