var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"ripserer","category":"page"},{"location":"api/#Ripserer.ripserer","page":"API","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix{T}; dim_max=1, modulus=2, threshold=typemax(T))\nripserer(points, metric; dim_max=1, modulus=2, threshold=typemax(T))\n\nCompute the persistent homology of metric space represented by dists or points and metric.\n\nKeyoword Arguments\n\ndim_max: compute persistent homology up to this dimension.\nmodulus: compute persistent homology with coefficients in the prime field of integers            mod modulus.\nthreshold: compute persistent homology up to diameter smaller than threshold. Defaults to radius of input space.\nsparse: if true, use SparseRipsFiltration. Defaults to issparse(dists).\nratio: only keep intervals with death(interval) > birth(interval) * ratio. Defaults to 1.\n\n\n\n\n\nripserer(filtration::AbstractFiltration; dim_max=1)\n\nCompute persistent homology from filtration object.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"RipsFiltration","category":"page"},{"location":"api/#Ripserer.RipsFiltration","page":"API","title":"Ripserer.RipsFiltration","text":"RipsFiltration{T, S<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, S}\n\nConstructor\n\nRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=default_rips_threshold(dist),\n    edge_type=Simplex{1, modulus, T, Int, UInt}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"SparseRipsFiltration","category":"page"},{"location":"api/#Ripserer.SparseRipsFiltration","page":"API","title":"Ripserer.SparseRipsFiltration","text":"SparseRipsFiltration{T, S<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, S}\n\nThis type holds the information about the input values. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as ∞.\n\nConstructor\n\nSparseRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=default_rips_threshold(dist),\n    eltype=Simplex{modulus, T}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Simplex-Types-1","page":"API","title":"Simplex Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractSimplex","category":"page"},{"location":"api/#Ripserer.AbstractSimplex","page":"API","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, C, T}\n\nAn abstract type for representing simplices. A simplex is represented by its dimension, diameter, combinatorial index and coefficient value. It does not need to hold information about its the vertices it includes, since they can be recomputed from the index and dimension.\n\nD is the dimension, T is the type of distance and C is the coefficient type.\n\nInterface\n\nindex(::AbstractSimplex)\ncoef(::AbstractSimplex)\nset_coef(::AbstractSimplex, ::Any)\ndiam(::AbstractSimplex)\nvertices(::AbstractSimplex)\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"index(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.index-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.index","text":"index(simplex::AbstractSimplex)\n\nGet the combinatorial index of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coef","category":"page"},{"location":"api/#Ripserer.coef","page":"API","title":"Ripserer.coef","text":"coef(simplex::AbstractSimplex)\n\nGet the coefficient value of simplex.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"set_coef","category":"page"},{"location":"api/#Ripserer.set_coef","page":"API","title":"Ripserer.set_coef","text":"set_coef(simplex::AbstractSimplex, value)\n\nReturn new simplex with new coefficient value.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.diam","text":"diam(simplex::AbstractSimplex)\n\nGet the diameter of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"dim","category":"page"},{"location":"api/#Ripserer.dim","page":"API","title":"Ripserer.dim","text":"dim(::AbstractSimplex)\ndim(::Type{AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\n\n\n\n\ndim(::PersistenceDiagram)\n\nGet the dimension of persistence diagram.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"diam","category":"page"},{"location":"api/#Ripserer.diam","page":"API","title":"Ripserer.diam","text":"diam(simplex::AbstractSimplex)\n\nGet the diameter of simplex.\n\n\n\n\n\ndiam(flt::AbstractFiltration, vertices)\n\nGet the diameter of list of vertices i.e. diameter of simplex with vertices.\n\n\n\n\n\ndiam(flt::AbstractFiltration, simplex, vertices, vertex)\n\nGet the diameter of coface of simplex that is formed by adding vertex to vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Filtration-Types-1","page":"API","title":"Filtration Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFiltration","page":"API","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{T, S<:AbstractSimplex{C, T}}\n\nAn abstract type that holds information about the distances between vertices and the simplex type.\n\nInterface\n\nn_vertices(::AbstractFiltration) - return number of vertices in filtration.\nedges(::AbstractFiltration) - return all edges in filtration as (l, (i, j)) where l is the edge length and i and j are its endpoints.\ndiam(::AbstractFiltration, vs) - diameter of simplex with vertices in vs. Should return Infinity() if simplex is above threshold.\ndiam(::AbstractFiltration, sx::AbstractSimplex, vs, u) - diameter of simplex sx with vertices in vs and an added vertex u. Should return Infinity() if simplex is above threshold.\nSparseArrays.issparse(::Type{A}) where A<:AbstractFiltration - optional, defaults to false. Should be true if most of the simplices are expected to be skipped.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"AbstractFlagFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFlagFiltration","page":"API","title":"Ripserer.AbstractFlagFiltration","text":"AbstractFlagFiltration{T, S} <: AbstractFiltration{T, S}\n\nAn abstract flag filtration is a filtration of flag complexes. Its subtypes can overload dist(::AbstractFlagFiltration{T}, u, v)::Union{T, Infinity} instead of diam. diam(::AbstractFlagFiltration, ...) defaults to maximum dist among vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"n_vertices","category":"page"},{"location":"api/#Ripserer.n_vertices","page":"API","title":"Ripserer.n_vertices","text":"n_vertices(filtration::AbstractFiltration)\n\nNumber of vertices in filtration.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"edges","category":"page"},{"location":"api/#Ripserer.edges","page":"API","title":"Ripserer.edges","text":"edges(filtration::AbstractFiltration)\n\nGet edges in distance matrix in filtration, sorted by decresing length and increasing combinatorial index. Edges should be of type edge_type(filtration).\n\n\n\n\n\nedges(dist::AbstractMatrix{T}, thresh, S)\n\nReturn sorted edges of type S in distance matrix with length lower than thresh.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::Any)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractFiltration,Any}","page":"API","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, vertices)\n\nGet the diameter of list of vertices i.e. diameter of simplex with vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::Any, ::Any, ::Any)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractFiltration,Any,Any,Any}","page":"API","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, simplex, vertices, vertex)\n\nGet the diameter of coface of simplex that is formed by adding vertex to vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"SparseArrays.issparse(::AbstractFiltration)","category":"page"},{"location":"api/#SparseArrays.issparse-Tuple{AbstractFiltration}","page":"API","title":"SparseArrays.issparse","text":"SparseArrays.issparse(::Type{A}) where A<:AbstractFiltration\n\nReturn true if A is a sparse filtration. A filtration should be sparse if most simplices are to be skipped. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Plots; gr()","category":"page"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This package is still under development and is currently unregistered. To install it, run the following.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(\"https://github.com/mtsch/Ripserer.jl\")","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Generate 100 points sampled from a torus.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"n = 10\nr = 1\nR = 4\ntorus = [((R + r*cos(θ))*cos(φ), (R + r*cos(θ))*sin(φ), r*sin(θ))\n         for θ in range(0, 2π, length=n+1)[1:end-1]\n         for φ in range(0, 2π, length=n+1)[1:end-1]]","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Run Ripserer.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Ripserer\nresult = ripserer(torus)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Plot the result as a persistence diagram or barcode.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> using Plots; gr()\njulia> plot(result)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> barcode(result)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"We notice some noise around the diagonal. This can be mitigated by running Ripserer with ripserer(torus, ratio=2) or by simply filtering the diagram.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"result[2] = filter(x -> death(x) > 2birth(x), result[2])","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> plot(result)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> barcode(result)","category":"page"},{"location":"#Ripserer.jl-1","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient computation of persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Julia implementation of the ripser algorithm for persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
